{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pydavinci A lightly opinionated DaVinci Resolve Python API wrapper Provides auto completion, type hints and great API reference documentation. I really just wanted auto completion in the IDE and to program transcoding RAW formats pydavinci only works with Python 3.6.* , as that's a requirement on DaVinci Resolve's part. You also need the Studio version. For the newer DaVinci Resolve v18, currently in beta, newer Python installations are supported. Install pydavinci Install via pip using a Python 3.6 environment pip install pydavinci Then make sure external scripting is set to Local in Settings -> System -> General Now we just need to import it! from pydavinci import davinci resolve = davinci . Resolve () Check out the usage examples Or go deep in the documentation To-do and contributing Contributors are always welcome! I currently have a few things I want to change, some of them are: Document all possible values of get_setting and set_setting Add a better way of interfacing with the whole get_setting and set_setting methods using a proxy class or something to that effect Create a Marker class to inherit from for the objects that need it Auto launch Resolve when it's not open - I've ran into some issues while trying to connect to the C extension right after launching it, a dirty way to do it is to just implement a time.sleep before trying to import the fusionscript module, otherwise we'll need to create another entrypoint to the api for launching the process and then signaling when it's ready If you want to contribute feel free to open a pull request!","title":"Home"},{"location":"#install-pydavinci","text":"Install via pip using a Python 3.6 environment pip install pydavinci Then make sure external scripting is set to Local in Settings -> System -> General Now we just need to import it! from pydavinci import davinci resolve = davinci . Resolve () Check out the usage examples Or go deep in the documentation","title":"Install pydavinci"},{"location":"#to-do-and-contributing","text":"Contributors are always welcome! I currently have a few things I want to change, some of them are: Document all possible values of get_setting and set_setting Add a better way of interfacing with the whole get_setting and set_setting methods using a proxy class or something to that effect Create a Marker class to inherit from for the objects that need it Auto launch Resolve when it's not open - I've ran into some issues while trying to connect to the C extension right after launching it, a dirty way to do it is to just implement a time.sleep before trying to import the fusionscript module, otherwise we'll need to create another entrypoint to the api for launching the process and then signaling when it's ready If you want to contribute feel free to open a pull request!","title":"To-do and contributing"},{"location":"folder/","text":"Bases: object Attributes Folder . clips property Gets all clips Returns: Type Description List [ MediaPoolItem ] list of clips Folder . name property Gets folder name Returns: Name Type Description name str folder name Folder . subfolders property Gets subfolders Returns: Name Type Description subfolders List [ Folder ] subfolders Functions","title":"Folder"},{"location":"folder/#pydavinci.wrappers.folder.Folder-attributes","text":"","title":"Attributes"},{"location":"folder/#pydavinci.wrappers.folder.Folder.clips","text":"Gets all clips Returns: Type Description List [ MediaPoolItem ] list of clips","title":"clips"},{"location":"folder/#pydavinci.wrappers.folder.Folder.name","text":"Gets folder name Returns: Name Type Description name str folder name","title":"name"},{"location":"folder/#pydavinci.wrappers.folder.Folder.subfolders","text":"Gets subfolders Returns: Name Type Description subfolders List [ Folder ] subfolders","title":"subfolders"},{"location":"folder/#pydavinci.wrappers.folder.Folder-functions","text":"","title":"Functions"},{"location":"mediapool/","text":"Bases: object Attributes MediaPool . root_folder property Gets media pool root folder Returns: Type Description Folder media pool root folder MediaPool . current_folder property Gets current mediapool folder Returns: Type Description Folder current mediapool folder Functions MediaPool . add_subfolder ( folder_name , parent_folder ) Adds subfolder folder_name into parent_folder Parameters: Name Type Description Default folder_name str subfolder name required parent_folder Folder parent folder object required Returns: Type Description Folder created subfolder MediaPool . create_empty_timeline ( timeline_name ) Creates empty timeline in current folder Parameters: Name Type Description Default timeline_name str timeline name required Returns: Type Description Timeline created timeline MediaPool . append_to_timeline ( clips ) Appends a list of MediaPoolItem s to current active timeline Parameters: Name Type Description Default clips List [ MediaPoolItem ] list of MediaPoolItem s to append required Returns: Type Description List [ TimelineItem ] list of inserted TimelineItem s MediaPool . create_timeline_from_clips ( name , clips ) Creates timeline name from clips Parameters: Name Type Description Default name str new timeline name required clips List [ MediaPoolItem ] list of MediaPoolItem s to use for creating the timeline required Returns: Type Description Timeline created timeline MediaPool . import_timeline_fromfile ( path , options = None ) Imports a timeline from path with options : options = { \"timelineName\" : str , # specifies the name of the timeline to be created \"importSourceClips\" : bool , # specifies whether source clips should be imported, True by default \"sourceClipsPath\" : str , # specifies a filesystem path to search for source clips if the media # is inaccessible in their original path and if \"importSourceClips\" is True \"sourceClipsFolders\" : List [ Folder ] # to search for source clips if the media is not present in current folder # and if \"importSourceClips\" is False \"interlaceProcessing\" : bool , # specifies whether to enable interlace processing on the imported # timeline being created. valid only for AAF import } Parameters: Name Type Description Default path str timeline file path required options dict Dict with import options. Defaults to None . None Returns: Type Description Timeline created timeline MediaPool . delete_timelines ( timelines ) Deletes timelines Parameters: Name Type Description Default timelines List [ Timeline ] list of timelines to be deleted required Returns: Name Type Description bool bool True if successful, False otherwise Info If you want to delete only one timeline, you can wrap it in a single element list. MediaPool . set_current_folder ( folder ) Sets current mediapool folder Parameters: Name Type Description Default folder Folder desired Folder required Returns: Name Type Description bool bool True if successful, False otherwise MediaPool . delete_clips ( clips ) Delete clips Parameters: Name Type Description Default clips List [ MediaPoolItem ] list of MediaPoolItem s to be deleted required Returns: Name Type Description bool bool True if successful, False otherwise MediaPool . delete_folders ( folders ) Delete folders Parameters: Name Type Description Default folders List [ Folder ] list of Folder s to be deleted required Returns: Name Type Description bool bool True if successful, False otherwise MediaPool . move_clips ( clips , folder ) Moves clips inside current active folder to folder Parameters: Name Type Description Default clips List [ MediaPoolItem ] list of MediaPoolItem s on current folder required folder Folder destination folder required Returns: Name Type Description bool bool True if successful, False otherwise MediaPool . move_folders ( folders , target_folder ) Move folders to target_folder Parameters: Name Type Description Default folders List [ Folder ] List of folders to be moved. If you want to only use one folder, wrap it in a list. required target_folder Folder target Folder required Returns: Name Type Description bool bool True if successful, False otherwise MediaPool . clip_mattes ( clip ) Gets paths of clip mattes from clip Parameters: Name Type Description Default clip MediaPoolItem clip to get mattes from required Returns: Type Description List [ str ] list of file paths associated with clip 's mattes MediaPool . timeline_mattes ( folder ) Gets timeline mattes inside folder Parameters: Name Type Description Default folder Folder folder to get timeline mattes from required Returns: Type Description List [ MediaPoolItem ] list of timeline mattes MediaPool . delete_mattes_by_path ( clip , path ) Delete mattes based on their file paths. Parameters: Name Type Description Default clip MediaPoolItem clip to have mattes deleted required path List [ str ] list of matte paths required Returns: Name Type Description bool bool description MediaPool . relink_clips ( clips , parent_folder ) Update the folder location of specified media pool clips with the specified folder path. Parameters: Name Type Description Default clips List [ MediaPoolItem ] MediaPoolItem s to relink required parent_folder str new parent folder required Returns: Name Type Description bool bool True if successful, False otherwise MediaPool . unlink_clips ( clips ) Unlink clips Parameters: Name Type Description Default clips List [ MediaPoolItem ] clips to be made offline required Returns: Name Type Description bool bool True if successful, False otherwise MediaPool . import_media ( paths ) Import media from paths Parameters: Name Type Description Default paths List [ str ] list of paths containing the media required Returns: Type Description List [ MediaPoolItem ] list of imported MediaPoolItem s Image Sequences Doesn't support image sequences yet. MediaPool . export_metadata ( file_name , clips = None ) Exports metadata of specified clips to file_name.csv . If no clips are specified, all clips from MediaPool will be used. Parameters: Name Type Description Default file_name str description required clips List [ MediaPoolItem ] list of clips to be processed, defaults to None None Returns: Name Type Description bool bool True if successful, False otherwise","title":"MediaPool"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool-attributes","text":"","title":"Attributes"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.root_folder","text":"Gets media pool root folder Returns: Type Description Folder media pool root folder","title":"root_folder"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.current_folder","text":"Gets current mediapool folder Returns: Type Description Folder current mediapool folder","title":"current_folder"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool-functions","text":"","title":"Functions"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.add_subfolder","text":"Adds subfolder folder_name into parent_folder Parameters: Name Type Description Default folder_name str subfolder name required parent_folder Folder parent folder object required Returns: Type Description Folder created subfolder","title":"add_subfolder()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.create_empty_timeline","text":"Creates empty timeline in current folder Parameters: Name Type Description Default timeline_name str timeline name required Returns: Type Description Timeline created timeline","title":"create_empty_timeline()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.append_to_timeline","text":"Appends a list of MediaPoolItem s to current active timeline Parameters: Name Type Description Default clips List [ MediaPoolItem ] list of MediaPoolItem s to append required Returns: Type Description List [ TimelineItem ] list of inserted TimelineItem s","title":"append_to_timeline()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.create_timeline_from_clips","text":"Creates timeline name from clips Parameters: Name Type Description Default name str new timeline name required clips List [ MediaPoolItem ] list of MediaPoolItem s to use for creating the timeline required Returns: Type Description Timeline created timeline","title":"create_timeline_from_clips()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.import_timeline_fromfile","text":"Imports a timeline from path with options : options = { \"timelineName\" : str , # specifies the name of the timeline to be created \"importSourceClips\" : bool , # specifies whether source clips should be imported, True by default \"sourceClipsPath\" : str , # specifies a filesystem path to search for source clips if the media # is inaccessible in their original path and if \"importSourceClips\" is True \"sourceClipsFolders\" : List [ Folder ] # to search for source clips if the media is not present in current folder # and if \"importSourceClips\" is False \"interlaceProcessing\" : bool , # specifies whether to enable interlace processing on the imported # timeline being created. valid only for AAF import } Parameters: Name Type Description Default path str timeline file path required options dict Dict with import options. Defaults to None . None Returns: Type Description Timeline created timeline","title":"import_timeline_fromfile()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.delete_timelines","text":"Deletes timelines Parameters: Name Type Description Default timelines List [ Timeline ] list of timelines to be deleted required Returns: Name Type Description bool bool True if successful, False otherwise Info If you want to delete only one timeline, you can wrap it in a single element list.","title":"delete_timelines()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.set_current_folder","text":"Sets current mediapool folder Parameters: Name Type Description Default folder Folder desired Folder required Returns: Name Type Description bool bool True if successful, False otherwise","title":"set_current_folder()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.delete_clips","text":"Delete clips Parameters: Name Type Description Default clips List [ MediaPoolItem ] list of MediaPoolItem s to be deleted required Returns: Name Type Description bool bool True if successful, False otherwise","title":"delete_clips()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.delete_folders","text":"Delete folders Parameters: Name Type Description Default folders List [ Folder ] list of Folder s to be deleted required Returns: Name Type Description bool bool True if successful, False otherwise","title":"delete_folders()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.move_clips","text":"Moves clips inside current active folder to folder Parameters: Name Type Description Default clips List [ MediaPoolItem ] list of MediaPoolItem s on current folder required folder Folder destination folder required Returns: Name Type Description bool bool True if successful, False otherwise","title":"move_clips()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.move_folders","text":"Move folders to target_folder Parameters: Name Type Description Default folders List [ Folder ] List of folders to be moved. If you want to only use one folder, wrap it in a list. required target_folder Folder target Folder required Returns: Name Type Description bool bool True if successful, False otherwise","title":"move_folders()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.clip_mattes","text":"Gets paths of clip mattes from clip Parameters: Name Type Description Default clip MediaPoolItem clip to get mattes from required Returns: Type Description List [ str ] list of file paths associated with clip 's mattes","title":"clip_mattes()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.timeline_mattes","text":"Gets timeline mattes inside folder Parameters: Name Type Description Default folder Folder folder to get timeline mattes from required Returns: Type Description List [ MediaPoolItem ] list of timeline mattes","title":"timeline_mattes()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.delete_mattes_by_path","text":"Delete mattes based on their file paths. Parameters: Name Type Description Default clip MediaPoolItem clip to have mattes deleted required path List [ str ] list of matte paths required Returns: Name Type Description bool bool description","title":"delete_mattes_by_path()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.relink_clips","text":"Update the folder location of specified media pool clips with the specified folder path. Parameters: Name Type Description Default clips List [ MediaPoolItem ] MediaPoolItem s to relink required parent_folder str new parent folder required Returns: Name Type Description bool bool True if successful, False otherwise","title":"relink_clips()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.unlink_clips","text":"Unlink clips Parameters: Name Type Description Default clips List [ MediaPoolItem ] clips to be made offline required Returns: Name Type Description bool bool True if successful, False otherwise","title":"unlink_clips()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.import_media","text":"Import media from paths Parameters: Name Type Description Default paths List [ str ] list of paths containing the media required Returns: Type Description List [ MediaPoolItem ] list of imported MediaPoolItem s Image Sequences Doesn't support image sequences yet.","title":"import_media()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.export_metadata","text":"Exports metadata of specified clips to file_name.csv . If no clips are specified, all clips from MediaPool will be used. Parameters: Name Type Description Default file_name str description required clips List [ MediaPoolItem ] list of clips to be processed, defaults to None None Returns: Name Type Description bool bool True if successful, False otherwise","title":"export_metadata()"},{"location":"mediapoolitem/","text":"Bases: object Attributes MediaPoolItem . name property Returns: Type Description str MediaPoolItem name MediaPoolItem . media_id property Returns: Type Description str MediaPoolItem UUID MediaPoolItem . markers property Gets markers Returns: Name Type Description dict Dict [ Any , Any ] markers MediaPoolItem . flags property Gets flag list Returns: Type Description List [ str ] list of valid flag colors MediaPoolItem . color writable property Gets or sets clip color Parameters: Name Type Description Default color str new clip color required Returns: Type Description str clip color MediaPoolItem . properties property Gets all clip properties Returns: Name Type Description dict Union [ str , Dict [ Any , Any ]] dict with clip properties Functions MediaPoolItem . get_metadata ( metadata_key ) Gets metadata metadata_key for MediaPoolItem . If metadata_key is not provided, returns a Dict with all available metadata. Parameters: Name Type Description Default metadata_key Optional [ Any ] metadata key required Returns: Type Description Union [ str , Dict [ Any , Any ]] Dict or str corresponding to metadata_key MediaPoolItem . set_metadata ( meta_dict ) Sets metadata with meta_dict : meta_dict = { metadata_key : metadata value } It's recommended you validate which metadata you wan't to change first by using MediaPoolItem.get_metadata() and getting a dict with all the metadata to see which one you want to alter. This will probably change for the better for version 1.0 Parameters: Name Type Description Default meta_dict dict dict with metadata to be set required Returns: Name Type Description bool bool True if successful, False otherwise MediaPoolItem . add_marker ( frameid , color , name , * , note = '' , duration = 1 , customdata = '' ) Adds a marker. customdata is a str that can be used for programatically setting and searching for markers. It's not exposed to the GUI. Parameters: Name Type Description Default frameid int frame for marker to be inserted at required color str marker color required name str marker name required note str marker note. Defaults to empty. '' duration int marker duration. Defaults to 1 frame. 1 customdata str custom user data. Defaults to empty. '' Returns: Name Type Description bool bool True if successful, False otherwise MediaPoolItem . get_custom_marker ( customdata ) Gets custom marker by customdata Parameters: Name Type Description Default customdata str custom data string required Returns: Name Type Description dict Dict [ Any , Any ] dict with marker data MediaPoolItem . update_custom_marker ( frameid , customdata ) Updates marker at frameid with new customdata Parameters: Name Type Description Default frameid int marker frame required customdata str new customdata required Returns: Name Type Description bool bool True if successful, False otherwise MediaPoolItem . get_marker_custom_data ( frameid ) Gets marker customdata at frameid Parameters: Name Type Description Default frameid int marker frame required Returns: Type Description str customdata MediaPoolItem . delete_marker ( * , frameid = 0 , color = '' , customdata = '' ) Deletes marker using frameid , color or customdata Parameters: Name Type Description Default frameid int frameid to use for choosing which markers to delete 0 color str color to use for choosing which markers to delete '' customdata str custom data to use for choosing which markers to delete '' Raises: Type Description ValueError no valid params provided Returns: Name Type Description bool bool True if successful, False otherwise Deleting Markers When selecting by frameid , will delete single marker When selecting by color , will delete all markers with provided color When selecting by customdata , will delete first marker with matching custom data MediaPoolItem . add_flag ( color ) Adds a flag Parameters: Name Type Description Default color str flag color required Returns: Name Type Description bool bool True if successful, False otherwise MediaPoolItem . clear_flags ( color = 'All' ) Clears flags Parameters: Name Type Description Default color str Clears flag by color . If none provided, defaults to \"All\" which clears all flags. 'All' Returns: Type Description bool True if successful, False otherwise MediaPoolItem . clear_color () Clears clip color Returns: Name Type Description bool bool True if successful, False otherwise MediaPoolItem . set_property ( name , value ) Sets property Parameters: Name Type Description Default name str property name required value str property value required Returns: Name Type Description bool bool True if successful, False otherwise MediaPoolItem . link_proxy ( path ) Links media located at path to this MediaPoolItem Parameters: Name Type Description Default path str absolute path to proxy media required Returns: Name Type Description bool bool True if successful, False otherwise MediaPoolItem . unlink_proxy () Unlinks proxy media of this MediaPoolItem Returns: Name Type Description bool bool True if successful, False otherwise MediaPoolItem . replace_clip ( path ) Replaces the underlying asset and metadata of MediaPoolItem with the specified absolute clip path. Parameters: Name Type Description Default path str path to clip required Returns: Name Type Description bool bool True if successful, False otherwise","title":"MediaPool Item"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem-attributes","text":"","title":"Attributes"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.name","text":"Returns: Type Description str MediaPoolItem name","title":"name"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.media_id","text":"Returns: Type Description str MediaPoolItem UUID","title":"media_id"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.markers","text":"Gets markers Returns: Name Type Description dict Dict [ Any , Any ] markers","title":"markers"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.flags","text":"Gets flag list Returns: Type Description List [ str ] list of valid flag colors","title":"flags"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.color","text":"Gets or sets clip color Parameters: Name Type Description Default color str new clip color required Returns: Type Description str clip color","title":"color"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.properties","text":"Gets all clip properties Returns: Name Type Description dict Union [ str , Dict [ Any , Any ]] dict with clip properties","title":"properties"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem-functions","text":"","title":"Functions"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.get_metadata","text":"Gets metadata metadata_key for MediaPoolItem . If metadata_key is not provided, returns a Dict with all available metadata. Parameters: Name Type Description Default metadata_key Optional [ Any ] metadata key required Returns: Type Description Union [ str , Dict [ Any , Any ]] Dict or str corresponding to metadata_key","title":"get_metadata()"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.set_metadata","text":"Sets metadata with meta_dict : meta_dict = { metadata_key : metadata value } It's recommended you validate which metadata you wan't to change first by using MediaPoolItem.get_metadata() and getting a dict with all the metadata to see which one you want to alter. This will probably change for the better for version 1.0 Parameters: Name Type Description Default meta_dict dict dict with metadata to be set required Returns: Name Type Description bool bool True if successful, False otherwise","title":"set_metadata()"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.add_marker","text":"Adds a marker. customdata is a str that can be used for programatically setting and searching for markers. It's not exposed to the GUI. Parameters: Name Type Description Default frameid int frame for marker to be inserted at required color str marker color required name str marker name required note str marker note. Defaults to empty. '' duration int marker duration. Defaults to 1 frame. 1 customdata str custom user data. Defaults to empty. '' Returns: Name Type Description bool bool True if successful, False otherwise","title":"add_marker()"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.get_custom_marker","text":"Gets custom marker by customdata Parameters: Name Type Description Default customdata str custom data string required Returns: Name Type Description dict Dict [ Any , Any ] dict with marker data","title":"get_custom_marker()"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.update_custom_marker","text":"Updates marker at frameid with new customdata Parameters: Name Type Description Default frameid int marker frame required customdata str new customdata required Returns: Name Type Description bool bool True if successful, False otherwise","title":"update_custom_marker()"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.get_marker_custom_data","text":"Gets marker customdata at frameid Parameters: Name Type Description Default frameid int marker frame required Returns: Type Description str customdata","title":"get_marker_custom_data()"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.delete_marker","text":"Deletes marker using frameid , color or customdata Parameters: Name Type Description Default frameid int frameid to use for choosing which markers to delete 0 color str color to use for choosing which markers to delete '' customdata str custom data to use for choosing which markers to delete '' Raises: Type Description ValueError no valid params provided Returns: Name Type Description bool bool True if successful, False otherwise Deleting Markers When selecting by frameid , will delete single marker When selecting by color , will delete all markers with provided color When selecting by customdata , will delete first marker with matching custom data","title":"delete_marker()"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.add_flag","text":"Adds a flag Parameters: Name Type Description Default color str flag color required Returns: Name Type Description bool bool True if successful, False otherwise","title":"add_flag()"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.clear_flags","text":"Clears flags Parameters: Name Type Description Default color str Clears flag by color . If none provided, defaults to \"All\" which clears all flags. 'All' Returns: Type Description bool True if successful, False otherwise","title":"clear_flags()"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.clear_color","text":"Clears clip color Returns: Name Type Description bool bool True if successful, False otherwise","title":"clear_color()"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.set_property","text":"Sets property Parameters: Name Type Description Default name str property name required value str property value required Returns: Name Type Description bool bool True if successful, False otherwise","title":"set_property()"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.link_proxy","text":"Links media located at path to this MediaPoolItem Parameters: Name Type Description Default path str absolute path to proxy media required Returns: Name Type Description bool bool True if successful, False otherwise","title":"link_proxy()"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.unlink_proxy","text":"Unlinks proxy media of this MediaPoolItem Returns: Name Type Description bool bool True if successful, False otherwise","title":"unlink_proxy()"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.replace_clip","text":"Replaces the underlying asset and metadata of MediaPoolItem with the specified absolute clip path. Parameters: Name Type Description Default path str path to clip required Returns: Name Type Description bool bool True if successful, False otherwise","title":"replace_clip()"},{"location":"mediastorage/","text":"Bases: object Attributes MediaStorage . mounted_volumes property Gets list of OS mounted volumes Returns: Name Type Description list List [ Any ] list of volumes Functions MediaStorage . get_subfolders ( folder_path ) Gets subfolders on folder_path Parameters: Name Type Description Default folder_path str parent folder required Returns: Type Description List [ str ] List[str]: list of subfolders MediaStorage . get_file_list ( folder_path ) Gets list of file on folder_path Parameters: Name Type Description Default folder_path str parent folder required Returns: Type Description List [ str ] List[str]: list of files in parent_folder MediaStorage . reveal_in_storage ( path ) Opens path in media storage Parameters: Name Type Description Default path str path required Returns: Name Type Description None bool None MediaStorage . add_clip_mattes ( mediapool_item , paths , stereo_eye ) Adds clip mattes from path in mediapool_item Parameters: Name Type Description Default mediapool_item MediaPoolItem a MediaPoolItem object required paths Union [ List [ str ], str ] A list of path strings or a single path string required Returns: Name Type Description bool bool True if successful, False otherwise MediaStorage . add_timelilne_mattes ( paths ) Adds timeline mattes into media pool Parameters: Name Type Description Default paths Union [ List [ str ], str ] a list of path strings or a single path string to a timeline matte required Returns: Type Description List ['MediaPoolItem'] List[MediaPoolItem]: list of timeline mattes MediaPoolItem s MediaStorage . addclips_to_mediapool ( item ) Adds clips to media pool Parameters: Name Type Description Default item List [ str ] a list of media paths or folders to add to media pool required Returns: Type Description List ['MediaPoolItem'] List[MediaPoolItem]: list of added MediaPoolItem s Info Even if you only added one clip, the returned MediaPoolItem will be inside a list. Access it directly by slicing it with the 0 index.","title":"MediaStorage"},{"location":"mediastorage/#pydavinci.wrappers.mediastorage.MediaStorage-attributes","text":"","title":"Attributes"},{"location":"mediastorage/#pydavinci.wrappers.mediastorage.MediaStorage.mounted_volumes","text":"Gets list of OS mounted volumes Returns: Name Type Description list List [ Any ] list of volumes","title":"mounted_volumes"},{"location":"mediastorage/#pydavinci.wrappers.mediastorage.MediaStorage-functions","text":"","title":"Functions"},{"location":"mediastorage/#pydavinci.wrappers.mediastorage.MediaStorage.get_subfolders","text":"Gets subfolders on folder_path Parameters: Name Type Description Default folder_path str parent folder required Returns: Type Description List [ str ] List[str]: list of subfolders","title":"get_subfolders()"},{"location":"mediastorage/#pydavinci.wrappers.mediastorage.MediaStorage.get_file_list","text":"Gets list of file on folder_path Parameters: Name Type Description Default folder_path str parent folder required Returns: Type Description List [ str ] List[str]: list of files in parent_folder","title":"get_file_list()"},{"location":"mediastorage/#pydavinci.wrappers.mediastorage.MediaStorage.reveal_in_storage","text":"Opens path in media storage Parameters: Name Type Description Default path str path required Returns: Name Type Description None bool None","title":"reveal_in_storage()"},{"location":"mediastorage/#pydavinci.wrappers.mediastorage.MediaStorage.add_clip_mattes","text":"Adds clip mattes from path in mediapool_item Parameters: Name Type Description Default mediapool_item MediaPoolItem a MediaPoolItem object required paths Union [ List [ str ], str ] A list of path strings or a single path string required Returns: Name Type Description bool bool True if successful, False otherwise","title":"add_clip_mattes()"},{"location":"mediastorage/#pydavinci.wrappers.mediastorage.MediaStorage.add_timelilne_mattes","text":"Adds timeline mattes into media pool Parameters: Name Type Description Default paths Union [ List [ str ], str ] a list of path strings or a single path string to a timeline matte required Returns: Type Description List ['MediaPoolItem'] List[MediaPoolItem]: list of timeline mattes MediaPoolItem s","title":"add_timelilne_mattes()"},{"location":"mediastorage/#pydavinci.wrappers.mediastorage.MediaStorage.addclips_to_mediapool","text":"Adds clips to media pool Parameters: Name Type Description Default item List [ str ] a list of media paths or folders to add to media pool required Returns: Type Description List ['MediaPoolItem'] List[MediaPoolItem]: list of added MediaPoolItem s Info Even if you only added one clip, the returned MediaPoolItem will be inside a list. Access it directly by slicing it with the 0 index.","title":"addclips_to_mediapool()"},{"location":"project/","text":"Bases: object Attributes Project . mediapool property Returns the MediaPool object. Returns: Type Description MediaPool Media Storage object Project . timeline_count property Get total timeline count on current project Returns: Type Description int timeline count Project . name writable property Gets or sets current project name Returns: Type Description str project name Project . presets property Gets a list of available project presets Returns: Type Description List [ str ] project presets Project . render_jobs property Gets current list of render jobs Returns: Name Type Description list List [ str ] render job list Project . render_presets property Gets available render presets list Returns: Name Type Description list List [ str ] available render presets list Project . render_formats property Gets all possible render formats. Returns: Name Type Description dict Dict [ Any , Any ] dict with render formats Project . current_render_format_and_codec property Gets current render format and codec. Returns: Name Type Description dict Dict [ Any , Any ] dict with current render format and codec Project . render_mode writable property Gets or sets current render mode. single for single clip and individual for individual clips. Returns: Type Description str render mode single or individual Project . timeline property Returns current Timeline object Returns: Name Type Description Timeline Timeline timeline object Functions Project . set_preset ( preset_name ) Activates preset_name Parameters: Name Type Description Default preset_name str preset name required Returns: Name Type Description bool bool True if successful, False otherwise Project . add_renderjob ( block = True ) Adds current render settings to a render job. If there are already rendered jobs in the render queue and you're executing a lot of commands, there's a bug on the Davinci API that there's a chance it will return an empty string instead of the job ID. block blocks the program until we get a job id back from Davinci Resolve. It's True by default. Returns: Name Type Description str str render job id Project . delete_renderjob ( job_id ) Deletes render job job_id Parameters: Name Type Description Default job_id str render job id required Returns: Name Type Description bool bool True if successful, False otherwise Project . delete_all_renderjobs () Deletes all renderjobs Returns: Name Type Description bool bool True if successful, False otherwise Project . render ( job_ids = None , interactive = True ) Render jobs Parameters: Name Type Description Default job_ids Union [None, List [ str ]] Renders provided list of job ids . If None provided, render all jobs in queue. Defaults to None . None interactive bool Whether to use interactive mode. When set to True , enables error feedback in the UI during rendering. True Returns: Name Type Description bool bool True if successful, False otherwise Project . stop_render () Stops all rendering. Returns: Name Type Description None None None Project . render_status ( job_id ) Gets render status on job_id Parameters: Name Type Description Default job_id str job id required Returns: Name Type Description dict Dict [ Any , Union [ str , int ]] dictionary with render status Render Status The dictionary returned looks like this when rendering: { 'JobStatus' : 'Rendering' , 'CompletionPercentage' : 92 , 'EstimatedTimeRemainingInMs' : 1000 } And like this when the render on the provided job id is complete: { 'JobStatus' : 'Complete' , 'CompletionPercentage' : 100 , 'TimeTakenToRenderInMs' : 25991 } Project . get_render_codecs ( render_format ) Returns all possible render codecs. Parameters: Name Type Description Default render_format str render format required Returns: Type Description Dict [ Any , Any ] Dict[Any, Any]: render codecs Project . set_render_format_and_codec ( format , codec ) Sets current format and codec Parameters: Name Type Description Default format str render format required codec str render codec required Returns: Name Type Description bool bool True if successful, False otherwise Project . available_resolutions ( format = None , codec = None ) Returns list of resolutions applicable for the given render format and render codec . Returns full list of resolutions if no argument is provided. Each element in the list is a dictionary with 2 keys \"Width\" and \"Height\". Parameters: Name Type Description Default format str render format None codec str render codec None Returns: Type Description List [ Dict [ Any , Any ]] List[Dict[Any, Any]]: description Project . is_rendering () Checks if DaVinci Resolve is rendering. Returns: Name Type Description bool bool True if rendering, False otherwise Project . load_render_preset ( preset_name ) Loads render preset preset_name . Parameters: Name Type Description Default preset_name str preset name required Returns: Name Type Description bool bool True if successful, False otherwise Project . save_render_preset_as ( preset_name ) Save current preset as preset_name . Parameters: Name Type Description Default preset_name str preset name required Returns: Name Type Description bool bool True if successful, False otherwise Project . set_render_settings ( render_settings ) Set render settings. Render Settings: render_settings = { \"SelectAllFrames\" : bool , # (when set True, the settings MarkIn and MarkOut are ignored) \"MarkIn\" : int , \"MarkOut\" : int , \"TargetDir\" : str , \"CustomName\" : str , \"UniqueFilenameStyle\" : int , # 0 - Prefix, 1 - Suffix. \"ExportVideo\" : bool , \"ExportAudio\" : bool , \"FormatWidth\" : int , \"FormatHeight\" : int , \"FrameRate\" : float , # (examples: 23.976, 24) \"PixelAspectRatio\" : str , # (for SD resolution: \"16_9\" or \"4_3\") (other resolutions: \"square\" or \"cinemascope\") \"VideoQuality\" : Union [ int , str ], # possible values for current codec (if applicable): # 0 (int) - will set quality to automatic # [1 -> MAX] (int) - will set input bit rate # [\"Least\", \"Low\", \"Medium\", \"High\", \"Best\"] (String) - will set input quality level \"AudioCodec\" : str , # (example: \"aac\") \"AudioBitDepth\" : int , \"AudioSampleRate\" : int , \"ColorSpaceTag\" : str , # (example: \"Same as Project\", \"AstroDesign\") \"GammaTag\" : str , # (example: \"Same as Project\", \"ACEScct\") \"ExportAlpha\" : bool , \"EncodingProfile\" : str , # (example: \"Main10\"). Can only be set for H.264 and H.265. \"MultiPassEncode\" : bool , # Can only be set for H.264. \"AlphaMode\" : int , # 0 - Premultiplied, 1 - Straight. Can only be set if \"ExportAlpha\" is true. \"NetworkOptimization\" : bool , # Only supported by QuickTime and MP4 formats. Parameters: Name Type Description Default render_settings dict dictionary with render settings required Returns: Name Type Description bool bool True if successful, False otherwise Project . get_setting ( setting ) Get project setting. Parameters: Name Type Description Default setting str setting name required Returns: Name Type Description dict Any dict with setting name and value Project . set_setting ( setting , value ) Set project setting. Parameters: Name Type Description Default setting str setting name required value Any setting value required Returns: Name Type Description bool bool True if successful, False otherwise Project . save () Saves project. Returns: Name Type Description bool bool True if successful, False otherwise Project . close () Closes current project. Returns: Name Type Description bool bool True if successful, False otherwise Project . open_timeline ( name ) Opens timeline named name . Parameters: Name Type Description Default name str timeline name required Returns: Name Type Description bool bool True if successful, False otherwise Project . refresh_luts () Refresh luts. Returns: Name Type Description None bool None","title":"Project"},{"location":"project/#pydavinci.wrappers.project.Project-attributes","text":"","title":"Attributes"},{"location":"project/#pydavinci.wrappers.project.Project.mediapool","text":"Returns the MediaPool object. Returns: Type Description MediaPool Media Storage object","title":"mediapool"},{"location":"project/#pydavinci.wrappers.project.Project.timeline_count","text":"Get total timeline count on current project Returns: Type Description int timeline count","title":"timeline_count"},{"location":"project/#pydavinci.wrappers.project.Project.name","text":"Gets or sets current project name Returns: Type Description str project name","title":"name"},{"location":"project/#pydavinci.wrappers.project.Project.presets","text":"Gets a list of available project presets Returns: Type Description List [ str ] project presets","title":"presets"},{"location":"project/#pydavinci.wrappers.project.Project.render_jobs","text":"Gets current list of render jobs Returns: Name Type Description list List [ str ] render job list","title":"render_jobs"},{"location":"project/#pydavinci.wrappers.project.Project.render_presets","text":"Gets available render presets list Returns: Name Type Description list List [ str ] available render presets list","title":"render_presets"},{"location":"project/#pydavinci.wrappers.project.Project.render_formats","text":"Gets all possible render formats. Returns: Name Type Description dict Dict [ Any , Any ] dict with render formats","title":"render_formats"},{"location":"project/#pydavinci.wrappers.project.Project.current_render_format_and_codec","text":"Gets current render format and codec. Returns: Name Type Description dict Dict [ Any , Any ] dict with current render format and codec","title":"current_render_format_and_codec"},{"location":"project/#pydavinci.wrappers.project.Project.render_mode","text":"Gets or sets current render mode. single for single clip and individual for individual clips. Returns: Type Description str render mode single or individual","title":"render_mode"},{"location":"project/#pydavinci.wrappers.project.Project.timeline","text":"Returns current Timeline object Returns: Name Type Description Timeline Timeline timeline object","title":"timeline"},{"location":"project/#pydavinci.wrappers.project.Project-functions","text":"","title":"Functions"},{"location":"project/#pydavinci.wrappers.project.Project.set_preset","text":"Activates preset_name Parameters: Name Type Description Default preset_name str preset name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"set_preset()"},{"location":"project/#pydavinci.wrappers.project.Project.add_renderjob","text":"Adds current render settings to a render job. If there are already rendered jobs in the render queue and you're executing a lot of commands, there's a bug on the Davinci API that there's a chance it will return an empty string instead of the job ID. block blocks the program until we get a job id back from Davinci Resolve. It's True by default. Returns: Name Type Description str str render job id","title":"add_renderjob()"},{"location":"project/#pydavinci.wrappers.project.Project.delete_renderjob","text":"Deletes render job job_id Parameters: Name Type Description Default job_id str render job id required Returns: Name Type Description bool bool True if successful, False otherwise","title":"delete_renderjob()"},{"location":"project/#pydavinci.wrappers.project.Project.delete_all_renderjobs","text":"Deletes all renderjobs Returns: Name Type Description bool bool True if successful, False otherwise","title":"delete_all_renderjobs()"},{"location":"project/#pydavinci.wrappers.project.Project.render","text":"Render jobs Parameters: Name Type Description Default job_ids Union [None, List [ str ]] Renders provided list of job ids . If None provided, render all jobs in queue. Defaults to None . None interactive bool Whether to use interactive mode. When set to True , enables error feedback in the UI during rendering. True Returns: Name Type Description bool bool True if successful, False otherwise","title":"render()"},{"location":"project/#pydavinci.wrappers.project.Project.stop_render","text":"Stops all rendering. Returns: Name Type Description None None None","title":"stop_render()"},{"location":"project/#pydavinci.wrappers.project.Project.render_status","text":"Gets render status on job_id Parameters: Name Type Description Default job_id str job id required Returns: Name Type Description dict Dict [ Any , Union [ str , int ]] dictionary with render status Render Status The dictionary returned looks like this when rendering: { 'JobStatus' : 'Rendering' , 'CompletionPercentage' : 92 , 'EstimatedTimeRemainingInMs' : 1000 } And like this when the render on the provided job id is complete: { 'JobStatus' : 'Complete' , 'CompletionPercentage' : 100 , 'TimeTakenToRenderInMs' : 25991 }","title":"render_status()"},{"location":"project/#pydavinci.wrappers.project.Project.get_render_codecs","text":"Returns all possible render codecs. Parameters: Name Type Description Default render_format str render format required Returns: Type Description Dict [ Any , Any ] Dict[Any, Any]: render codecs","title":"get_render_codecs()"},{"location":"project/#pydavinci.wrappers.project.Project.set_render_format_and_codec","text":"Sets current format and codec Parameters: Name Type Description Default format str render format required codec str render codec required Returns: Name Type Description bool bool True if successful, False otherwise","title":"set_render_format_and_codec()"},{"location":"project/#pydavinci.wrappers.project.Project.available_resolutions","text":"Returns list of resolutions applicable for the given render format and render codec . Returns full list of resolutions if no argument is provided. Each element in the list is a dictionary with 2 keys \"Width\" and \"Height\". Parameters: Name Type Description Default format str render format None codec str render codec None Returns: Type Description List [ Dict [ Any , Any ]] List[Dict[Any, Any]]: description","title":"available_resolutions()"},{"location":"project/#pydavinci.wrappers.project.Project.is_rendering","text":"Checks if DaVinci Resolve is rendering. Returns: Name Type Description bool bool True if rendering, False otherwise","title":"is_rendering()"},{"location":"project/#pydavinci.wrappers.project.Project.load_render_preset","text":"Loads render preset preset_name . Parameters: Name Type Description Default preset_name str preset name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"load_render_preset()"},{"location":"project/#pydavinci.wrappers.project.Project.save_render_preset_as","text":"Save current preset as preset_name . Parameters: Name Type Description Default preset_name str preset name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"save_render_preset_as()"},{"location":"project/#pydavinci.wrappers.project.Project.set_render_settings","text":"Set render settings. Render Settings: render_settings = { \"SelectAllFrames\" : bool , # (when set True, the settings MarkIn and MarkOut are ignored) \"MarkIn\" : int , \"MarkOut\" : int , \"TargetDir\" : str , \"CustomName\" : str , \"UniqueFilenameStyle\" : int , # 0 - Prefix, 1 - Suffix. \"ExportVideo\" : bool , \"ExportAudio\" : bool , \"FormatWidth\" : int , \"FormatHeight\" : int , \"FrameRate\" : float , # (examples: 23.976, 24) \"PixelAspectRatio\" : str , # (for SD resolution: \"16_9\" or \"4_3\") (other resolutions: \"square\" or \"cinemascope\") \"VideoQuality\" : Union [ int , str ], # possible values for current codec (if applicable): # 0 (int) - will set quality to automatic # [1 -> MAX] (int) - will set input bit rate # [\"Least\", \"Low\", \"Medium\", \"High\", \"Best\"] (String) - will set input quality level \"AudioCodec\" : str , # (example: \"aac\") \"AudioBitDepth\" : int , \"AudioSampleRate\" : int , \"ColorSpaceTag\" : str , # (example: \"Same as Project\", \"AstroDesign\") \"GammaTag\" : str , # (example: \"Same as Project\", \"ACEScct\") \"ExportAlpha\" : bool , \"EncodingProfile\" : str , # (example: \"Main10\"). Can only be set for H.264 and H.265. \"MultiPassEncode\" : bool , # Can only be set for H.264. \"AlphaMode\" : int , # 0 - Premultiplied, 1 - Straight. Can only be set if \"ExportAlpha\" is true. \"NetworkOptimization\" : bool , # Only supported by QuickTime and MP4 formats. Parameters: Name Type Description Default render_settings dict dictionary with render settings required Returns: Name Type Description bool bool True if successful, False otherwise","title":"set_render_settings()"},{"location":"project/#pydavinci.wrappers.project.Project.get_setting","text":"Get project setting. Parameters: Name Type Description Default setting str setting name required Returns: Name Type Description dict Any dict with setting name and value","title":"get_setting()"},{"location":"project/#pydavinci.wrappers.project.Project.set_setting","text":"Set project setting. Parameters: Name Type Description Default setting str setting name required value Any setting value required Returns: Name Type Description bool bool True if successful, False otherwise","title":"set_setting()"},{"location":"project/#pydavinci.wrappers.project.Project.save","text":"Saves project. Returns: Name Type Description bool bool True if successful, False otherwise","title":"save()"},{"location":"project/#pydavinci.wrappers.project.Project.close","text":"Closes current project. Returns: Name Type Description bool bool True if successful, False otherwise","title":"close()"},{"location":"project/#pydavinci.wrappers.project.Project.open_timeline","text":"Opens timeline named name . Parameters: Name Type Description Default name str timeline name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"open_timeline()"},{"location":"project/#pydavinci.wrappers.project.Project.refresh_luts","text":"Refresh luts. Returns: Name Type Description None bool None","title":"refresh_luts()"},{"location":"projectmanager/","text":"Bases: object Attributes ProjectManager . projects property Returns a list with project names in current project manager folder Returns: Type Description List [ str ] List[str]: list of project names ProjectManager . folders property Returns a list with project manager folder names Returns: Type Description List [ str ] List[str]: list of folder names ProjectManager . folder property Returns current folder name Returns: Name Type Description str str folder name ProjectManager . db writable property Gets or sets current database. For setting a Disk DB ProjectManager . db = { 'DbType' : 'Disk' , 'DbName' : 'Local Database' } For setting a PostgresSQL db ProjectManager . db = { 'DbType' : 'PostgreSQL' , 'DbName' : 'PostgresDB' , 'IpAddress' : '127.0.0.1' } Parameters: Name Type Description Default db_info dict valid db_info dict. required Returns: Name Type Description bool Dict [ str , str ] True if successful, False otherwise ProjectManager . db_list property Returns list of all databases Returns: Type Description List [ Dict [ str , str ]] list of databases Functions ProjectManager . create_project ( project_name ) Creates a project with project_name Parameters: Name Type Description Default project_name str project name required Returns: Name Type Description Project Project Project ProjectManager . delete_project ( project_name ) Deletes project project_name Parameters: Name Type Description Default project_name str project name required Returns: Name Type Description bool bool True if successful, False otherwise ProjectManager . load_project ( project_name ) Loads project project_name Parameters: Name Type Description Default project_name str project name required Returns: Name Type Description bool Project True if successful, False otherwise ProjectManager . close_project ( project_name ) Closes project project_name Parameters: Name Type Description Default project_name str project name required Returns: Name Type Description bool bool True if successful, False otherwise ProjectManager . create_folder ( folder_name ) Creates project manager folder folder_name Parameters: Name Type Description Default folder_name str folder name required Returns: Name Type Description bool bool True if successful, False otherwise ProjectManager . delete_folder ( folder_name ) Deletes project manager folder folder_name Parameters: Name Type Description Default folder_name str folder name required Returns: Name Type Description bool bool True if successful, False otherwise ProjectManager . goto_root_folder () Goes to root project manager folder Returns: Name Type Description bool bool True if successful, False otherwise ProjectManager . goto_parent_folder () Goes to parent of current project manager folder Returns: Name Type Description bool bool True if successful, False otherwise ProjectManager . open_folder ( folder_name ) Open folder named folder_name Parameters: Name Type Description Default folder_name str folder name required Returns: Name Type Description bool bool True if successful, False otherwise ProjectManager . import_project ( path ) Imports .drp project located at path Parameters: Name Type Description Default path str path to .drp project required Returns: Name Type Description bool bool True if successful, False otherwise ProjectManager . export_project ( project_name , path , stills_and_luts = False ) Exports project Parameters: Name Type Description Default project_name str project to be exported required path str path to export to required stills_and_luts bool whether to export with Stills and LUTs. Defaults to False. False Returns: Name Type Description bool bool True if successful, False otherwise ProjectManager . restore_project ( path ) Restore project from path Parameters: Name Type Description Default path str project path required Returns: Name Type Description bool bool True if successful, False otherwise","title":"ProjectManager"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager-attributes","text":"","title":"Attributes"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.projects","text":"Returns a list with project names in current project manager folder Returns: Type Description List [ str ] List[str]: list of project names","title":"projects"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.folders","text":"Returns a list with project manager folder names Returns: Type Description List [ str ] List[str]: list of folder names","title":"folders"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.folder","text":"Returns current folder name Returns: Name Type Description str str folder name","title":"folder"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.db","text":"Gets or sets current database. For setting a Disk DB ProjectManager . db = { 'DbType' : 'Disk' , 'DbName' : 'Local Database' } For setting a PostgresSQL db ProjectManager . db = { 'DbType' : 'PostgreSQL' , 'DbName' : 'PostgresDB' , 'IpAddress' : '127.0.0.1' } Parameters: Name Type Description Default db_info dict valid db_info dict. required Returns: Name Type Description bool Dict [ str , str ] True if successful, False otherwise","title":"db"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.db_list","text":"Returns list of all databases Returns: Type Description List [ Dict [ str , str ]] list of databases","title":"db_list"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager-functions","text":"","title":"Functions"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.create_project","text":"Creates a project with project_name Parameters: Name Type Description Default project_name str project name required Returns: Name Type Description Project Project Project","title":"create_project()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.delete_project","text":"Deletes project project_name Parameters: Name Type Description Default project_name str project name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"delete_project()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.load_project","text":"Loads project project_name Parameters: Name Type Description Default project_name str project name required Returns: Name Type Description bool Project True if successful, False otherwise","title":"load_project()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.close_project","text":"Closes project project_name Parameters: Name Type Description Default project_name str project name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"close_project()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.create_folder","text":"Creates project manager folder folder_name Parameters: Name Type Description Default folder_name str folder name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"create_folder()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.delete_folder","text":"Deletes project manager folder folder_name Parameters: Name Type Description Default folder_name str folder name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"delete_folder()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.goto_root_folder","text":"Goes to root project manager folder Returns: Name Type Description bool bool True if successful, False otherwise","title":"goto_root_folder()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.goto_parent_folder","text":"Goes to parent of current project manager folder Returns: Name Type Description bool bool True if successful, False otherwise","title":"goto_parent_folder()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.open_folder","text":"Open folder named folder_name Parameters: Name Type Description Default folder_name str folder name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"open_folder()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.import_project","text":"Imports .drp project located at path Parameters: Name Type Description Default path str path to .drp project required Returns: Name Type Description bool bool True if successful, False otherwise","title":"import_project()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.export_project","text":"Exports project Parameters: Name Type Description Default project_name str project to be exported required path str path to export to required stills_and_luts bool whether to export with Stills and LUTs. Defaults to False. False Returns: Name Type Description bool bool True if successful, False otherwise","title":"export_project()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.restore_project","text":"Restore project from path Parameters: Name Type Description Default path str project path required Returns: Name Type Description bool bool True if successful, False otherwise","title":"restore_project()"},{"location":"resolve/","text":"Bases: object Attributes Resolve . pages = [ 'media' , 'cut' , 'edit' , 'fusion' , 'color' , 'fairlight' , 'deliver' ] instance-attribute Available pages to switch to using Resolve.page Resolve . project_manager property Returns the ProjectManager object. Returns: Type Description ProjectManager Project Manager object Resolve . media_storage property Returns the MediaStorage object. Returns: Type Description MediaStorage Media Storage object Resolve . media_pool property Returns the MediaPool object. Returns: Type Description MediaPool Media Storage object Resolve . project property Returns the current active Project object. Returns: Type Description Project Project object Resolve . active_timeline property Returns the current active Timeline object. Returns: Type Description Timeline Timeline object Resolve . page writable property Gets or sets current Resolve Page . Note that certain methods are only available when in the right page. Parameters: Name Type Description Default page str valid page required Returns: Name Type Description None str None Resolve . product_name property Returns: Name Type Description str str product name Resolve . version property Returns: Name Type Description str str version Resolve . fusion property Returns the Fusion object. Fusion Object This is object is the same as the regular Fusion API. You can call fusion.__dir__() to see all available methods. See The last Fusion API documentation for more details. Returns: Type Description Fusion Fusion object Functions Resolve . load_layout ( layout_name ) Loads saved layout named layout_name Parameters: Name Type Description Default layout_name str layout name required Returns: Name Type Description bool bool True if successful, False otherwise Resolve . update_layout ( layout_name ) Updates current layout to layout_name Parameters: Name Type Description Default layout_name str layout to be updated required Returns: Name Type Description bool bool True if successful, False otherwise Resolve . save_layout ( layout_name ) Saves current layout as layout_name Parameters: Name Type Description Default layout_name str layout name required Returns: Name Type Description bool bool True if successful, False otherwise Resolve . import_layout ( path , layout_name ) Import layout_name from path Parameters: Name Type Description Default path str path to layout file required layout_name str name to be imported as required Returns: Name Type Description bool bool True if successful, False otherwise Resolve . quit () Quits Davinci Resolve Returns: Name Type Description None None None","title":"Resolve"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve-attributes","text":"","title":"Attributes"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.pages","text":"Available pages to switch to using Resolve.page","title":"pages"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.project_manager","text":"Returns the ProjectManager object. Returns: Type Description ProjectManager Project Manager object","title":"project_manager"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.media_storage","text":"Returns the MediaStorage object. Returns: Type Description MediaStorage Media Storage object","title":"media_storage"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.media_pool","text":"Returns the MediaPool object. Returns: Type Description MediaPool Media Storage object","title":"media_pool"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.project","text":"Returns the current active Project object. Returns: Type Description Project Project object","title":"project"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.active_timeline","text":"Returns the current active Timeline object. Returns: Type Description Timeline Timeline object","title":"active_timeline"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.page","text":"Gets or sets current Resolve Page . Note that certain methods are only available when in the right page. Parameters: Name Type Description Default page str valid page required Returns: Name Type Description None str None","title":"page"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.product_name","text":"Returns: Name Type Description str str product name","title":"product_name"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.version","text":"Returns: Name Type Description str str version","title":"version"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.fusion","text":"Returns the Fusion object. Fusion Object This is object is the same as the regular Fusion API. You can call fusion.__dir__() to see all available methods. See The last Fusion API documentation for more details. Returns: Type Description Fusion Fusion object","title":"fusion"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve-functions","text":"","title":"Functions"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.load_layout","text":"Loads saved layout named layout_name Parameters: Name Type Description Default layout_name str layout name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"load_layout()"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.update_layout","text":"Updates current layout to layout_name Parameters: Name Type Description Default layout_name str layout to be updated required Returns: Name Type Description bool bool True if successful, False otherwise","title":"update_layout()"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.save_layout","text":"Saves current layout as layout_name Parameters: Name Type Description Default layout_name str layout name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"save_layout()"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.import_layout","text":"Import layout_name from path Parameters: Name Type Description Default path str path to layout file required layout_name str name to be imported as required Returns: Name Type Description bool bool True if successful, False otherwise","title":"import_layout()"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.quit","text":"Quits Davinci Resolve Returns: Name Type Description None None None","title":"quit()"},{"location":"timeline/","text":"Bases: object Attributes Timeline . name writable property Gets or sets timeline name Parameters: Name Type Description Default name str new timeline name required Returns: Name Type Description bool str True if successful, False otherwise Timeline . start_frame property Gets timeline start frame Returns: Name Type Description int int start frame Timeline . end_frame property Gets timeline end frame Returns: Name Type Description int int end frame Timeline . markers property Gets markers Returns: Name Type Description dict Dict [ Any , Any ] markers Timeline . timecode property Gets current timecode Returns: Name Type Description str str timecode Timeline . current_video_item property Returns current video TimelineItem Returns: Name Type Description TimelineItem 'TimelineItem' current TimelineItem Timeline . current_clip_thumbnail property Returns a dict with data containing metadata + raw thumbnail image data (RGB 8-bit image data encoded in base64 format) for current media in the Color Page. Returns: Name Type Description dict Dict [ Any , Any ] (keys \"width\", \"height\", \"format\" and \"data\") Functions Timeline . activate () Makes this timeline active Returns: Name Type Description bool bool True if successful, False otherwise Timeline . track_count ( track_type ) Gets track count on track_type Parameters: Name Type Description Default track_type str valid track_types : video , audio , subtitle required Raises: Type Description ValueError Not a valid track type Returns: Name Type Description int int number of tracks Timeline . items ( track_type , track_index ) Gets TimelineItem s from a track Parameters: Name Type Description Default track_type str valid track_type : video , audio , subtitle required track_index int track index. Starts at 1 required Raises: Type Description ValueError Not a valid track type Returns: Type Description List [ TimelineItem ] list of items at specified track Timeline . add_marker ( frameid , color , name , * , note = '' , duration = 1 , customdata = '' ) Adds a marker. customdata is a str that can be used for programatically setting and searching for markers. It's not exposed to the GUI. Parameters: Name Type Description Default frameid int frame for marker to be inserted at required color str marker color required name str marker name required note str marker note. Defaults to empty. '' duration int marker duration. Defaults to 1 frame. 1 customdata str custom user data. Defaults to empty. '' Returns: Name Type Description bool bool True if successful, False otherwise Timeline . get_custom_marker ( customdata ) Gets custom marker by customdata Parameters: Name Type Description Default customdata str custom data string required Returns: Name Type Description dict Dict [ Any , Any ] dict with marker data Timeline . update_custom_marker ( frameid , customdata ) Updates marker at frameid with new customdata Parameters: Name Type Description Default frameid int marker frame required customdata str new customdata required Returns: Name Type Description bool bool True if successful, False otherwise Timeline . get_marker_custom_data ( frameid ) Gets marker customdata at frameid Parameters: Name Type Description Default frameid int marker frame required Returns: Type Description str customdata Timeline . delete_marker ( * , frameid = 0 , color = '' , customdata = '' ) Deletes marker using frameid , color or customdata Parameters: Name Type Description Default frameid int frameid to use for choosing which markers to delete 0 color str color to use for choosing which markers to delete '' customdata str custom data to use for choosing which markers to delete '' Raises: Type Description ValueError no valid params provided Returns: Name Type Description bool bool True if successful, False otherwise Deleting Markers When selecting by frameid , will delete single marker When selecting by color , will delete all markers with provided color When selecting by customdata , will delete first marker with matching custom data Timeline . apply_grade_from_DRX ( drx_path , grade_mode , timeline_items ) Applies drx grade on a list of TimelineItem s Parameters: Name Type Description Default drx_path str path to a .drx file required grade_mode int grade mode to use. 0 for No Keyframes , 1 for Source Timecode aligned and 2 for Start Frames aligned . required timeline_items List [ TimelineItem ] timeline items to apply grade to required Returns: Name Type Description bool bool True if successful, False otherwise Timeline . get_track_name ( track_type , track_index ) Gets track name Parameters: Name Type Description Default track_type str valid track_type: video , audio or subtitle required track_index int track index. Starts at 1 required Raises: Type Description ValueError Not a valid track type Returns: Name Type Description str str track name Timeline . set_track_name ( track_type , track_index , new_name ) Sets track name Parameters: Name Type Description Default track_type str valid track_type: video , audio or subtitle required track_index int track index. Starts at 1 required new_name str new name required Raises: Type Description ValueError Not a valid track type Returns: Type Description bool True if successful, False otherwise Timeline . duplicate_timeline ( timeline_name = None ) Duplicates this timeline Parameters: Name Type Description Default timeline_name str New timeline name. If not provided, appends \"Copy\" to timeline name. None Returns: Type Description Timeline new duplicated timeline Timeline . create_compound_clip ( timeline_items , clip_info = None ) Creates a compound clip using timeline_items Parameters: Name Type Description Default timeline_items List [ TimelineItem ] list of TimelineItem s to use required clip_info dict optional compound clip settings. Valid dict: { \"startTimecode\" : \"00:00:00:00\" , \"name\" : \"Compound Clip 1\" } None Returns: Type Description TimelineItem compound clip Timeline . create_fusion_clip ( timeline_items ) Creates a Fusion clip with timeline_items Parameters: Name Type Description Default timeline_items List [ TimelineItem ] timeline items to be used as input in the Fusion clip required Returns: Type Description TimelineItem resulting fusion clip Timeline . import_aaf_into_timeline ( file_path , import_options = None ) Imports an aaf into the timeline Import Options Imports timeline items from an AAF file and optional import_options dict into the timeline, with support for the keys: \"autoImportSourceClipsIntoMediaPool\" : bool , specifies if source clips should be imported into media pool, True by default \"ignoreFileExtensionsWhenMatching\" : bool , specifies if file extensions should be ignored when matching, False by default \"linkToSourceCameraFiles\" : bool, specifies if link to source camera files should be enabled, False by default \"useSizingInfo\" : bool , specifies if sizing information should be used, False by default \"importMultiChannelAudioTracksAsLinkedGroups\" : bool, specifies if multi-channel audio tracks should be imported as linked groups, False by default \"insertAdditionalTracks\" : bool, specifies if additional tracks should be inserted, True by default \"insertWithOffset\" : str , specifies insert with offset value in timecode format - defaults to \"00:00:00:00\" , applicable if \"insertAdditionalTracks\" is False \"sourceClipsPath\" : str , specifies a filesystem path to search for source clips if the media is inaccessible in their original path and if \"ignoreFileExtensionsWhenMatching\" is True \"sourceClipsFolders\" : str , list of Folder objects to search for source clips if the media is not present in current folder Parameters: Name Type Description Default file_path str path to .aaf file required import_options dict optional import options. See description above. Defaults to {}. None Returns: Name Type Description bool bool True if successful, False otherwise Timeline . export ( file_name , export_type , export_subtype ) Exports timeline file (.aaf, .xml, etc) Supported export_type : resolve . EXPORT_AAF resolve . EXPORT_DRT resolve . EXPORT_EDL resolve . EXPORT_FCP_7_XML resolve . EXPORT_FCPXML_1_3 resolve . EXPORT_FCPXML_1_4 resolve . EXPORT_FCPXML_1_5 resolve . EXPORT_FCPXML_1_6 resolve . EXPORT_FCPXML_1_7 resolve . EXPORT_FCPXML_1_8 resolve . EXPORT_HDR_10_PROFILE_A resolve . EXPORT_HDR_10_PROFILE_B resolve . EXPORT_TEXT_CSV resolve . EXPORT_TEXT_TAB resolve . EXPORT_DOLBY_VISION_VER_2_9 resolve . EXPORT_DOLBY_VISION_VER_4_0 Supported export_subtype : resolve . EXPORT_NONE resolve . EXPORT_AAF_NEW resolve . EXPORT_AAF_EXISTING resolve . EXPORT_CDL resolve . EXPORT_SDL resolve . EXPORT_MISSING_CLIPS Export types and subtypes Please note that export_subtype is a required parameter for resolve.EXPORT_AAF and resolve.EXPORT_EDL . For rest of the export_type , export_subtype is ignored. When exportType is resolve.EXPORT_AAF , valid export_subtype values are resolve.EXPORT_AAF_NEW and resolve.EXPORT_AAF_EXISTING . When exportType is resolve.EXPORT_EDL , valid exportSubtype values are resolve.EXPORT_CDL , resolve.EXPORT_SDL , resolve.EXPORT_MISSING_CLIPS and resolve.EXPORT_NONE . Note: Replace resolve. when using the constants above, if a different Resolve class instance name is used. Parameters: Name Type Description Default file_name str full filepath to export to including file name required export_type _type_ supported export type required export_subtype _type_ supported export subtype required Returns: Name Type Description bool bool True if successful, False otherwise Timeline . get_setting ( settingname = None ) Gets setting Parameters: Name Type Description Default settingname str setting name. If none provided, returns all available settings in a dict. None Returns: Type Description str Union[str, Dict]: setting(s) Timeline . set_setting ( setting_name , value ) Set setting Parameters: Name Type Description Default setting_name str setting name required value Union[str, int, Dict[Any, Any] setting value required Returns: Type Description bool True if successful, False otherwise Timeline . insert_generator ( generator_name ) Inserts a generator in the timeline Parameters: Name Type Description Default generator_name str generator name to be inserted required Returns: Type Description TimelineItem generator Timeline . insert_fusion_generator ( generator_name ) Inserts a fusion generator in the timeline Parameters: Name Type Description Default generator_name str fusion generator name required Returns: Type Description TimelineItem fusion generator Timeline . insert_ofx_generator ( generator_name ) Inserts an OFX generator in the timeline Parameters: Name Type Description Default generator_name str OFX generator name required Returns: Type Description TimelineItem OFX generator Timeline . insert_title ( title_name ) Inserts a title in the timeline Parameters: Name Type Description Default title_name str title name required Returns: Type Description TimelineItem title Timeline . insert_fusion_title ( title_name ) Inserts a fusion title in the timeline Parameters: Name Type Description Default title_name str fusion title name required Returns: Type Description TimelineItem fusion title","title":"Timeline"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline-attributes","text":"","title":"Attributes"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.name","text":"Gets or sets timeline name Parameters: Name Type Description Default name str new timeline name required Returns: Name Type Description bool str True if successful, False otherwise","title":"name"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.start_frame","text":"Gets timeline start frame Returns: Name Type Description int int start frame","title":"start_frame"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.end_frame","text":"Gets timeline end frame Returns: Name Type Description int int end frame","title":"end_frame"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.markers","text":"Gets markers Returns: Name Type Description dict Dict [ Any , Any ] markers","title":"markers"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.timecode","text":"Gets current timecode Returns: Name Type Description str str timecode","title":"timecode"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.current_video_item","text":"Returns current video TimelineItem Returns: Name Type Description TimelineItem 'TimelineItem' current TimelineItem","title":"current_video_item"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.current_clip_thumbnail","text":"Returns a dict with data containing metadata + raw thumbnail image data (RGB 8-bit image data encoded in base64 format) for current media in the Color Page. Returns: Name Type Description dict Dict [ Any , Any ] (keys \"width\", \"height\", \"format\" and \"data\")","title":"current_clip_thumbnail"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline-functions","text":"","title":"Functions"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.activate","text":"Makes this timeline active Returns: Name Type Description bool bool True if successful, False otherwise","title":"activate()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.track_count","text":"Gets track count on track_type Parameters: Name Type Description Default track_type str valid track_types : video , audio , subtitle required Raises: Type Description ValueError Not a valid track type Returns: Name Type Description int int number of tracks","title":"track_count()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.items","text":"Gets TimelineItem s from a track Parameters: Name Type Description Default track_type str valid track_type : video , audio , subtitle required track_index int track index. Starts at 1 required Raises: Type Description ValueError Not a valid track type Returns: Type Description List [ TimelineItem ] list of items at specified track","title":"items()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.add_marker","text":"Adds a marker. customdata is a str that can be used for programatically setting and searching for markers. It's not exposed to the GUI. Parameters: Name Type Description Default frameid int frame for marker to be inserted at required color str marker color required name str marker name required note str marker note. Defaults to empty. '' duration int marker duration. Defaults to 1 frame. 1 customdata str custom user data. Defaults to empty. '' Returns: Name Type Description bool bool True if successful, False otherwise","title":"add_marker()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.get_custom_marker","text":"Gets custom marker by customdata Parameters: Name Type Description Default customdata str custom data string required Returns: Name Type Description dict Dict [ Any , Any ] dict with marker data","title":"get_custom_marker()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.update_custom_marker","text":"Updates marker at frameid with new customdata Parameters: Name Type Description Default frameid int marker frame required customdata str new customdata required Returns: Name Type Description bool bool True if successful, False otherwise","title":"update_custom_marker()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.get_marker_custom_data","text":"Gets marker customdata at frameid Parameters: Name Type Description Default frameid int marker frame required Returns: Type Description str customdata","title":"get_marker_custom_data()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.delete_marker","text":"Deletes marker using frameid , color or customdata Parameters: Name Type Description Default frameid int frameid to use for choosing which markers to delete 0 color str color to use for choosing which markers to delete '' customdata str custom data to use for choosing which markers to delete '' Raises: Type Description ValueError no valid params provided Returns: Name Type Description bool bool True if successful, False otherwise Deleting Markers When selecting by frameid , will delete single marker When selecting by color , will delete all markers with provided color When selecting by customdata , will delete first marker with matching custom data","title":"delete_marker()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.apply_grade_from_DRX","text":"Applies drx grade on a list of TimelineItem s Parameters: Name Type Description Default drx_path str path to a .drx file required grade_mode int grade mode to use. 0 for No Keyframes , 1 for Source Timecode aligned and 2 for Start Frames aligned . required timeline_items List [ TimelineItem ] timeline items to apply grade to required Returns: Name Type Description bool bool True if successful, False otherwise","title":"apply_grade_from_DRX()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.get_track_name","text":"Gets track name Parameters: Name Type Description Default track_type str valid track_type: video , audio or subtitle required track_index int track index. Starts at 1 required Raises: Type Description ValueError Not a valid track type Returns: Name Type Description str str track name","title":"get_track_name()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.set_track_name","text":"Sets track name Parameters: Name Type Description Default track_type str valid track_type: video , audio or subtitle required track_index int track index. Starts at 1 required new_name str new name required Raises: Type Description ValueError Not a valid track type Returns: Type Description bool True if successful, False otherwise","title":"set_track_name()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.duplicate_timeline","text":"Duplicates this timeline Parameters: Name Type Description Default timeline_name str New timeline name. If not provided, appends \"Copy\" to timeline name. None Returns: Type Description Timeline new duplicated timeline","title":"duplicate_timeline()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.create_compound_clip","text":"Creates a compound clip using timeline_items Parameters: Name Type Description Default timeline_items List [ TimelineItem ] list of TimelineItem s to use required clip_info dict optional compound clip settings. Valid dict: { \"startTimecode\" : \"00:00:00:00\" , \"name\" : \"Compound Clip 1\" } None Returns: Type Description TimelineItem compound clip","title":"create_compound_clip()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.create_fusion_clip","text":"Creates a Fusion clip with timeline_items Parameters: Name Type Description Default timeline_items List [ TimelineItem ] timeline items to be used as input in the Fusion clip required Returns: Type Description TimelineItem resulting fusion clip","title":"create_fusion_clip()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.import_aaf_into_timeline","text":"Imports an aaf into the timeline Import Options Imports timeline items from an AAF file and optional import_options dict into the timeline, with support for the keys: \"autoImportSourceClipsIntoMediaPool\" : bool , specifies if source clips should be imported into media pool, True by default \"ignoreFileExtensionsWhenMatching\" : bool , specifies if file extensions should be ignored when matching, False by default \"linkToSourceCameraFiles\" : bool, specifies if link to source camera files should be enabled, False by default \"useSizingInfo\" : bool , specifies if sizing information should be used, False by default \"importMultiChannelAudioTracksAsLinkedGroups\" : bool, specifies if multi-channel audio tracks should be imported as linked groups, False by default \"insertAdditionalTracks\" : bool, specifies if additional tracks should be inserted, True by default \"insertWithOffset\" : str , specifies insert with offset value in timecode format - defaults to \"00:00:00:00\" , applicable if \"insertAdditionalTracks\" is False \"sourceClipsPath\" : str , specifies a filesystem path to search for source clips if the media is inaccessible in their original path and if \"ignoreFileExtensionsWhenMatching\" is True \"sourceClipsFolders\" : str , list of Folder objects to search for source clips if the media is not present in current folder Parameters: Name Type Description Default file_path str path to .aaf file required import_options dict optional import options. See description above. Defaults to {}. None Returns: Name Type Description bool bool True if successful, False otherwise","title":"import_aaf_into_timeline()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.export","text":"Exports timeline file (.aaf, .xml, etc) Supported export_type : resolve . EXPORT_AAF resolve . EXPORT_DRT resolve . EXPORT_EDL resolve . EXPORT_FCP_7_XML resolve . EXPORT_FCPXML_1_3 resolve . EXPORT_FCPXML_1_4 resolve . EXPORT_FCPXML_1_5 resolve . EXPORT_FCPXML_1_6 resolve . EXPORT_FCPXML_1_7 resolve . EXPORT_FCPXML_1_8 resolve . EXPORT_HDR_10_PROFILE_A resolve . EXPORT_HDR_10_PROFILE_B resolve . EXPORT_TEXT_CSV resolve . EXPORT_TEXT_TAB resolve . EXPORT_DOLBY_VISION_VER_2_9 resolve . EXPORT_DOLBY_VISION_VER_4_0 Supported export_subtype : resolve . EXPORT_NONE resolve . EXPORT_AAF_NEW resolve . EXPORT_AAF_EXISTING resolve . EXPORT_CDL resolve . EXPORT_SDL resolve . EXPORT_MISSING_CLIPS Export types and subtypes Please note that export_subtype is a required parameter for resolve.EXPORT_AAF and resolve.EXPORT_EDL . For rest of the export_type , export_subtype is ignored. When exportType is resolve.EXPORT_AAF , valid export_subtype values are resolve.EXPORT_AAF_NEW and resolve.EXPORT_AAF_EXISTING . When exportType is resolve.EXPORT_EDL , valid exportSubtype values are resolve.EXPORT_CDL , resolve.EXPORT_SDL , resolve.EXPORT_MISSING_CLIPS and resolve.EXPORT_NONE . Note: Replace resolve. when using the constants above, if a different Resolve class instance name is used. Parameters: Name Type Description Default file_name str full filepath to export to including file name required export_type _type_ supported export type required export_subtype _type_ supported export subtype required Returns: Name Type Description bool bool True if successful, False otherwise","title":"export()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.get_setting","text":"Gets setting Parameters: Name Type Description Default settingname str setting name. If none provided, returns all available settings in a dict. None Returns: Type Description str Union[str, Dict]: setting(s)","title":"get_setting()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.set_setting","text":"Set setting Parameters: Name Type Description Default setting_name str setting name required value Union[str, int, Dict[Any, Any] setting value required Returns: Type Description bool True if successful, False otherwise","title":"set_setting()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.insert_generator","text":"Inserts a generator in the timeline Parameters: Name Type Description Default generator_name str generator name to be inserted required Returns: Type Description TimelineItem generator","title":"insert_generator()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.insert_fusion_generator","text":"Inserts a fusion generator in the timeline Parameters: Name Type Description Default generator_name str fusion generator name required Returns: Type Description TimelineItem fusion generator","title":"insert_fusion_generator()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.insert_ofx_generator","text":"Inserts an OFX generator in the timeline Parameters: Name Type Description Default generator_name str OFX generator name required Returns: Type Description TimelineItem OFX generator","title":"insert_ofx_generator()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.insert_title","text":"Inserts a title in the timeline Parameters: Name Type Description Default title_name str title name required Returns: Type Description TimelineItem title","title":"insert_title()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.insert_fusion_title","text":"Inserts a fusion title in the timeline Parameters: Name Type Description Default title_name str fusion title name required Returns: Type Description TimelineItem fusion title","title":"insert_fusion_title()"},{"location":"timelineitem/","text":"Bases: object Attributes TimelineItem . name property Gets name of TimelineItem Returns: Name Type Description str str name TimelineItem . duration property Get duration in frames Returns: Name Type Description int int duration in frames TimelineItem . start property Returns the start frame position on the timeline. Returns: Name Type Description int int start frame position TimelineItem . end property Returns the start frame position on the timeline. Returns: Name Type Description int int end frame position TimelineItem . left_offset property Returns the maximum extension by frame for clip from left side. Returns: Name Type Description int int left offset frame count TimelineItem . right_offset property Returns the maximum extension by frame for clip from right side. Returns: Name Type Description int int right offset frame count TimelineItem . markers property Gets markers Returns: Name Type Description dict Dict [ Any , Any ] markers TimelineItem . flags property Gets flag list Returns: Type Description List [ str ] List[str]: list of flags TimelineItem . color writable property Gets or sets clip color Parameters: Name Type Description Default color str color to be applied required Returns: Name Type Description bool str True if successful, False otherwise TimelineItem . mediapoolitem property Returns the corresponding MediaPoolItem for this TimelineItem Returns: Name Type Description MediaPoolItem 'MediaPoolItem' MediaPoolItem TimelineItem . take writable property Gets or sets current take Parameters: Name Type Description Default takeindex int take index for selection required TimelineItem . takes property Get total number of takes Returns: Name Type Description int int total number of takes Functions TimelineItem . add_marker ( frameid , color , name , * , note = '' , duration = 1 , customdata = '' ) Adds a marker. customdata is a str that can be used for programatically setting and searching for markers. It's not exposed to the GUI. Parameters: Name Type Description Default frameid int frame for marker to be inserted at required color str marker color required name str marker name required note str marker note. Defaults to empty. '' duration int marker duration. Defaults to 1 frame. 1 customdata str custom user data. Defaults to empty. '' Returns: Name Type Description bool bool True if successful, False otherwise TimelineItem . get_custom_marker ( customdata ) Gets custom marker by customdata Parameters: Name Type Description Default customdata str custom data string required Returns: Name Type Description dict Dict [ Any , Any ] dict with marker data TimelineItem . update_custom_marker ( frameid , customdata ) Updates marker at frameid with new customdata Parameters: Name Type Description Default frameid int marker frame required customdata str new customdata required Returns: Name Type Description bool bool True if successful, False otherwise TimelineItem . get_marker_custom_data ( frameid ) Gets marker customdata at frameid Parameters: Name Type Description Default frameid int marker frame required Returns: Type Description str customdata TimelineItem . delete_marker ( * , frameid = 0 , color = '' , customdata = '' ) Deletes marker using frameid , color or customdata Parameters: Name Type Description Default frameid int frameid to use for choosing which markers to delete 0 color str color to use for choosing which markers to delete '' customdata str custom data to use for choosing which markers to delete '' Raises: Type Description ValueError no valid params provided Returns: Name Type Description bool bool True if successful, False otherwise Deleting Markers When selecting by frameid , will delete single marker When selecting by color , will delete all markers with provided color When selecting by customdata , will delete first marker with matching custom data TimelineItem . add_flag ( color ) Adds flag Parameters: Name Type Description Default color str valid flag required Returns: Name Type Description bool bool True if successful, False otherwise TimelineItem . clear_flags ( color = 'All' ) Clears all flags Parameters: Name Type Description Default color str clears flags by color . If All provided, clear all flags. Defaults to \"All\". 'All' Returns: Name Type Description bool bool description TimelineItem . clear_color () Clears clip color Returns: Name Type Description bool bool True if successful, False otherwise TimelineItem . set_lut ( node_index , lut_path ) Sets lut located on lut_path at node_index Parameters: Name Type Description Default node_index int node index required lut_path str lut path required Returns: Name Type Description bool bool True if successful, False otherwise TimelineItem . set_cdl ( cdl ) Sets CDL Parameters: Name Type Description Default cdl dict valid CDL dict required Example myclip . set_cdl ({ \"NodeIndex\" : \"1\" , \"Slope\" : \"0.5 0.4 0.2\" , \"Offset\" : \"0.4 0.3 0.2\" , \"Power\" : \"0.6 0.7 0.8\" , \"Saturation\" : \"0.65\" }) Returns: Name Type Description bool bool True if successful, False otherwise TimelineItem . add_take ( mediapool_item , startframe = 0 , endframe = 0 ) Adds mediapool_item as a new take. Initializes a take selector for the timeline item if needed. By default, the full clip extents is added. startframe and endFrame are optional arguments used to specify the extents. Parameters: Name Type Description Default mediapool_item MediaPoolItem media pool item to add as take required startframe int start frame for new take. Defaults to 0. 0 endframe int end frame for new take. Defaults to 0. 0 Returns: Name Type Description bool bool description TimelineItem . take_info ( takeindex = 0 ) Gets take info. If no takeindex provided, uses current selected take. Parameters: Name Type Description Default takeindex int take index to get info from. Defaults to current take. 0 Returns: Name Type Description dict Dict [ Any , Any ] description TimelineItem . delete_take ( takeindex ) Deletes take index with index takeindex Parameters: Name Type Description Default takeindex int take index to be deleted required Returns: Name Type Description bool bool True if successful, False otherwise TimelineItem . finalize_take ( takeindex = 0 ) Finalizes take at takeindex . If no takeindex provided, finalizes current take. Parameters: Name Type Description Default takeindex int take index to be finalized. Defaults to current take. 0 Returns: Name Type Description bool bool description TimelineItem . copy_grade_to ( timeline_items ) Copies the current grade to all the items in timneline_items list Parameters: Name Type Description Default timeline_items list list with clips for the grade to be applied required Returns: Name Type Description bool bool True if successful, False otherwise","title":"TimelineItem"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem-attributes","text":"","title":"Attributes"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.name","text":"Gets name of TimelineItem Returns: Name Type Description str str name","title":"name"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.duration","text":"Get duration in frames Returns: Name Type Description int int duration in frames","title":"duration"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.start","text":"Returns the start frame position on the timeline. Returns: Name Type Description int int start frame position","title":"start"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.end","text":"Returns the start frame position on the timeline. Returns: Name Type Description int int end frame position","title":"end"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.left_offset","text":"Returns the maximum extension by frame for clip from left side. Returns: Name Type Description int int left offset frame count","title":"left_offset"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.right_offset","text":"Returns the maximum extension by frame for clip from right side. Returns: Name Type Description int int right offset frame count","title":"right_offset"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.markers","text":"Gets markers Returns: Name Type Description dict Dict [ Any , Any ] markers","title":"markers"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.flags","text":"Gets flag list Returns: Type Description List [ str ] List[str]: list of flags","title":"flags"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.color","text":"Gets or sets clip color Parameters: Name Type Description Default color str color to be applied required Returns: Name Type Description bool str True if successful, False otherwise","title":"color"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.mediapoolitem","text":"Returns the corresponding MediaPoolItem for this TimelineItem Returns: Name Type Description MediaPoolItem 'MediaPoolItem' MediaPoolItem","title":"mediapoolitem"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.take","text":"Gets or sets current take Parameters: Name Type Description Default takeindex int take index for selection required","title":"take"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.takes","text":"Get total number of takes Returns: Name Type Description int int total number of takes","title":"takes"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem-functions","text":"","title":"Functions"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.add_marker","text":"Adds a marker. customdata is a str that can be used for programatically setting and searching for markers. It's not exposed to the GUI. Parameters: Name Type Description Default frameid int frame for marker to be inserted at required color str marker color required name str marker name required note str marker note. Defaults to empty. '' duration int marker duration. Defaults to 1 frame. 1 customdata str custom user data. Defaults to empty. '' Returns: Name Type Description bool bool True if successful, False otherwise","title":"add_marker()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.get_custom_marker","text":"Gets custom marker by customdata Parameters: Name Type Description Default customdata str custom data string required Returns: Name Type Description dict Dict [ Any , Any ] dict with marker data","title":"get_custom_marker()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.update_custom_marker","text":"Updates marker at frameid with new customdata Parameters: Name Type Description Default frameid int marker frame required customdata str new customdata required Returns: Name Type Description bool bool True if successful, False otherwise","title":"update_custom_marker()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.get_marker_custom_data","text":"Gets marker customdata at frameid Parameters: Name Type Description Default frameid int marker frame required Returns: Type Description str customdata","title":"get_marker_custom_data()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.delete_marker","text":"Deletes marker using frameid , color or customdata Parameters: Name Type Description Default frameid int frameid to use for choosing which markers to delete 0 color str color to use for choosing which markers to delete '' customdata str custom data to use for choosing which markers to delete '' Raises: Type Description ValueError no valid params provided Returns: Name Type Description bool bool True if successful, False otherwise Deleting Markers When selecting by frameid , will delete single marker When selecting by color , will delete all markers with provided color When selecting by customdata , will delete first marker with matching custom data","title":"delete_marker()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.add_flag","text":"Adds flag Parameters: Name Type Description Default color str valid flag required Returns: Name Type Description bool bool True if successful, False otherwise","title":"add_flag()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.clear_flags","text":"Clears all flags Parameters: Name Type Description Default color str clears flags by color . If All provided, clear all flags. Defaults to \"All\". 'All' Returns: Name Type Description bool bool description","title":"clear_flags()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.clear_color","text":"Clears clip color Returns: Name Type Description bool bool True if successful, False otherwise","title":"clear_color()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.set_lut","text":"Sets lut located on lut_path at node_index Parameters: Name Type Description Default node_index int node index required lut_path str lut path required Returns: Name Type Description bool bool True if successful, False otherwise","title":"set_lut()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.set_cdl","text":"Sets CDL Parameters: Name Type Description Default cdl dict valid CDL dict required Example myclip . set_cdl ({ \"NodeIndex\" : \"1\" , \"Slope\" : \"0.5 0.4 0.2\" , \"Offset\" : \"0.4 0.3 0.2\" , \"Power\" : \"0.6 0.7 0.8\" , \"Saturation\" : \"0.65\" }) Returns: Name Type Description bool bool True if successful, False otherwise","title":"set_cdl()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.add_take","text":"Adds mediapool_item as a new take. Initializes a take selector for the timeline item if needed. By default, the full clip extents is added. startframe and endFrame are optional arguments used to specify the extents. Parameters: Name Type Description Default mediapool_item MediaPoolItem media pool item to add as take required startframe int start frame for new take. Defaults to 0. 0 endframe int end frame for new take. Defaults to 0. 0 Returns: Name Type Description bool bool description","title":"add_take()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.take_info","text":"Gets take info. If no takeindex provided, uses current selected take. Parameters: Name Type Description Default takeindex int take index to get info from. Defaults to current take. 0 Returns: Name Type Description dict Dict [ Any , Any ] description","title":"take_info()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.delete_take","text":"Deletes take index with index takeindex Parameters: Name Type Description Default takeindex int take index to be deleted required Returns: Name Type Description bool bool True if successful, False otherwise","title":"delete_take()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.finalize_take","text":"Finalizes take at takeindex . If no takeindex provided, finalizes current take. Parameters: Name Type Description Default takeindex int take index to be finalized. Defaults to current take. 0 Returns: Name Type Description bool bool description","title":"finalize_take()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.copy_grade_to","text":"Copies the current grade to all the items in timneline_items list Parameters: Name Type Description Default timeline_items list list with clips for the grade to be applied required Returns: Name Type Description bool bool True if successful, False otherwise","title":"copy_grade_to()"},{"location":"examples/premiereproxies/","text":"Premiere Proxies Just show me the code We all know about Premieres particular need for proxies. They have to be: Same aspect ratio as the original files Otherwise you end up with stretched proxies, and no one likes that. Same number of audio tracks as the original files This doesn't make sense, but that's how it is. Ideally same timecode Because otherwise you're going to have headaches. So you end up having to: Create proxies in Premiere and hope you have a nice 16x9 aspect ratio because that's what the default presets use. Realize you have media mixed between DCI 4k and UHD and now you gotta create an individual encoding preset Realize you have to create a Media Encoder encoding preset If you ever had to do that at 2am you know that it works so badly it's not even funny. You create the preset and it tries to copy the files, or it can't import the preset into Premiere, or a thousand other weird things. Then you decide to do just transcode everything in Davinci Resolve, which is probably what you should've done in the first place, but you still need to render everything in the same aspect ratio. Let's fix that and hopefully come home early The code Importing pydavinci Assuming we have pydavinci installed and have a Davinci project open, let's create a premiere_proxies.py file and import and define the objects we're going to use. premiere_proxies.py from pydavinci import davinci resolve = davinci . Resolve () project = resolve . project project_manager = resolve . project_manager media_pool = resolve . media_pool media_storage = resolve . media_storage Tip You can also programatically create a project. Check out Project Setting up a folder to import to Now let's create a folder on the media pool root folder, and set it as the current folder. ocf_folder = media_pool . add_subfolder ( 'OCF' , media_pool . root_folder ) media_pool . set_current_folder ( ocf_folder ) Info OCF means Original Camera Format Defining our function Let's define our function to generate the Premiere proxies: def generate_premiere_proxies ( input_dir , proxyfactor , output_dir ): Our function will take as parameters: input_dir : a path to a folder containing all our media output_dir : output directory for our proxies proxyfactor : by how much we will reduce the resolution for the proxies Info proxyfactor is the number to divide the original resolution to. Example: A proxyfactor of 1 on a 1920x1080 resolution will give you a 1920x1080 resolution proxy. A proxyfactor of 1.5 on a 1920x1080 resolution will give you a 1280x720 resolution proxy. A proxyfactor of 2 on a 1920x1080 resolution will give you a 960x540 resolution proxy Importing Media Now we can import the media in our project, and figure out what resolutions they are def generate_premiere_proxies ( input_dir , proxyfactor , output_dir ): media_pool . import_media ( input_dir ) clips_res = defaultdict ( list ) for media in ocf_folder . clips : clips_res [ media . properties [ 'Resolution' ]] . append ( media ) We first import our media using the media_pool.import_media() method, which imports all valid(as judged by Resolve) media files from input_dir into the media pool on our current folder. We then create a defaultdict that we will use to store all resolutions from the media. Then we loop for each MediaPoolItem in the ocf_folder.clips to grab each clip resolution, and store it in the clips_res dictionary which will end up looking like this: clips_res = { '1920x1080' : [ MediaPoolItem1 , MediaPoolItem2 ], '3840x2160' : [ MediaPoolItem3 , MediaPoolItem4 ], ... } Tip We're using a defaultdict to simplify our loop. If we used a regular dict, the first time we find a resolution we would have to first initiate it with a list value and then append to it. This way we don't need to check if we've seen this resolution before or not. Now while the Resolve API is very powerful, it still lacks a way for us to set the default behavior of exporting audio channels to Same as Source , which is what we need for Premiere.. So now let's head to Davinci and create and save a render preset with that option enabled. On the Audio tab, we make sure we're exporting audio and we select Same as source for the audio channels. This ensures that our proxy media can be linked without issue in Premiere. Save the preset as Proxies_Preset Now that we created our preset, let's make sure it's activated when we render the clips by using the project.set_preset() method. def generate_premiere_proxies ( input_dir , output_dir , proxyfactor ): ... project . set_preset ( \"Proxy_Preset\" ) We've imported and grabbed all clips resolutions, and now we can start our main loop. Creating render jobs First let's create an empty list which will contain our render jobs, then start our main loop and create a folder for each resolution we have and move the correct clips to that folder. def generate_premiere_proxies ( input_dir , output_dir , proxyfactor ): ... render_ids = [] for key in clips_res . keys (): res_x , res_y = key . split ( \"x\" ) # (1) res_folder = media_pool . add_subfolder ( key , ocf_folder ) clips = clips_res [ key ] # (2) media_pool . move_clips ( clips , res_folder ) When we grab resolutions from DaVinci, they come as a string, eg: \"1920x1080\" . We split the resolution to get the width and height We create a new variable containing the list of MediaPoolItem s for our current resolution in the loop. Make sure to click the buttons in the code above for more information Now we need to create a timeline containing all our MediaPoolItem s for the current resolution in the loop. We then activate that timeline and set the timeline resolution to be the same as the clip's resolutions, to avoid any letterboxing. def generate_premiere_proxies ( input_dir , output_dir , proxyfactor ): ... render_ids = [] for key in clips_res . keys (): ... media_pool . create_timeline_from_clips ( res_folder . name , # (1) res_folder . clips ) timeline = project . timeline timeline . set_setting ( \"useCustomSettings\" , \"1\" ) # (2) timeline . set_setting ( \"timelineResolutionWidth\" , res_x ) timeline . set_setting ( \"timelineResolutionHeight\" , res_y ) This is for the created timeline name. We're using the Folder name from before, which is set to be a string representing the resolution. This allows us to set custom resolutions and framerates for timelines more easily through the Python API, without having to mess with the Project Settings. For the next step, we need to set our render settings. Let's calculate our desired rendered resolution using our provided proxyfactor , set our render format/codec and output directory. def generate_premiere_proxies ( input_dir , output_dir , proxyfactor ): ... render_ids = [] for key in clips_res . keys (): ... project . set_render_format_and_codec ( \"mp4\" , \"H264\" ) render_settings = { # (1) \"FormatWidth\" : ( int ( res_x ) // proxyfactor ), # (2) \"FormatHeight\" : ( int ( res_y ) // proxyfactor ), \"TargetDir\" : output_dir , } project . set_render_settings ( render_settings ) The valid render settings that you can change are available at Project.set_render_settings() The \\\\ floor operator ensures we get an int back and not a float Warning If for any reason your render resolution ends up being an odd number, DaVinci will throw an error in the GUI and your script won't be able to continue. Now we're almost done! Just add the current timeline and render settings to the render queue, and append it to our render_ids list def generate_premiere_proxies ( input_dir , output_dir , proxyfactor ): ... render_ids = [] for key in clips_res . keys (): ... render_id = project . add_renderjob () render_ids . append ( render_id ) return render_ids Render time! Now we can get our job_ids and render them out!: job_ids = generate_premiere_proxies ( \"Path/To/Folder/With/Clips\" , \"Path/To/Output/Folder, proxyfactor = 2 , ) project . render ( job_ids ) Resolve will start rendering all our timelines with our clips, and in the end we'll have proxies ready to be edited by Premiere. Check out the full code here , with some extra functionality at the end which just prints out a nice message on render times left and total render time.","title":"Create Premiere Proxies"},{"location":"examples/premiereproxies/#premiere-proxies","text":"","title":"Premiere Proxies"},{"location":"examples/premiereproxies/#the-code","text":"","title":"The code"},{"location":"examples/premiereproxies/#importing-pydavinci","text":"Assuming we have pydavinci installed and have a Davinci project open, let's create a premiere_proxies.py file and import and define the objects we're going to use. premiere_proxies.py from pydavinci import davinci resolve = davinci . Resolve () project = resolve . project project_manager = resolve . project_manager media_pool = resolve . media_pool media_storage = resolve . media_storage Tip You can also programatically create a project. Check out Project","title":"Importing pydavinci"},{"location":"examples/premiereproxies/#setting-up-a-folder-to-import-to","text":"Now let's create a folder on the media pool root folder, and set it as the current folder. ocf_folder = media_pool . add_subfolder ( 'OCF' , media_pool . root_folder ) media_pool . set_current_folder ( ocf_folder ) Info OCF means Original Camera Format","title":"Setting up a folder to import to"},{"location":"examples/premiereproxies/#defining-our-function","text":"Let's define our function to generate the Premiere proxies: def generate_premiere_proxies ( input_dir , proxyfactor , output_dir ): Our function will take as parameters: input_dir : a path to a folder containing all our media output_dir : output directory for our proxies proxyfactor : by how much we will reduce the resolution for the proxies Info proxyfactor is the number to divide the original resolution to. Example: A proxyfactor of 1 on a 1920x1080 resolution will give you a 1920x1080 resolution proxy. A proxyfactor of 1.5 on a 1920x1080 resolution will give you a 1280x720 resolution proxy. A proxyfactor of 2 on a 1920x1080 resolution will give you a 960x540 resolution proxy","title":"Defining our function"},{"location":"examples/premiereproxies/#importing-media","text":"Now we can import the media in our project, and figure out what resolutions they are def generate_premiere_proxies ( input_dir , proxyfactor , output_dir ): media_pool . import_media ( input_dir ) clips_res = defaultdict ( list ) for media in ocf_folder . clips : clips_res [ media . properties [ 'Resolution' ]] . append ( media ) We first import our media using the media_pool.import_media() method, which imports all valid(as judged by Resolve) media files from input_dir into the media pool on our current folder. We then create a defaultdict that we will use to store all resolutions from the media. Then we loop for each MediaPoolItem in the ocf_folder.clips to grab each clip resolution, and store it in the clips_res dictionary which will end up looking like this: clips_res = { '1920x1080' : [ MediaPoolItem1 , MediaPoolItem2 ], '3840x2160' : [ MediaPoolItem3 , MediaPoolItem4 ], ... } Tip We're using a defaultdict to simplify our loop. If we used a regular dict, the first time we find a resolution we would have to first initiate it with a list value and then append to it. This way we don't need to check if we've seen this resolution before or not. Now while the Resolve API is very powerful, it still lacks a way for us to set the default behavior of exporting audio channels to Same as Source , which is what we need for Premiere.. So now let's head to Davinci and create and save a render preset with that option enabled. On the Audio tab, we make sure we're exporting audio and we select Same as source for the audio channels. This ensures that our proxy media can be linked without issue in Premiere. Save the preset as Proxies_Preset Now that we created our preset, let's make sure it's activated when we render the clips by using the project.set_preset() method. def generate_premiere_proxies ( input_dir , output_dir , proxyfactor ): ... project . set_preset ( \"Proxy_Preset\" ) We've imported and grabbed all clips resolutions, and now we can start our main loop.","title":"Importing Media"},{"location":"examples/premiereproxies/#creating-render-jobs","text":"First let's create an empty list which will contain our render jobs, then start our main loop and create a folder for each resolution we have and move the correct clips to that folder. def generate_premiere_proxies ( input_dir , output_dir , proxyfactor ): ... render_ids = [] for key in clips_res . keys (): res_x , res_y = key . split ( \"x\" ) # (1) res_folder = media_pool . add_subfolder ( key , ocf_folder ) clips = clips_res [ key ] # (2) media_pool . move_clips ( clips , res_folder ) When we grab resolutions from DaVinci, they come as a string, eg: \"1920x1080\" . We split the resolution to get the width and height We create a new variable containing the list of MediaPoolItem s for our current resolution in the loop. Make sure to click the buttons in the code above for more information Now we need to create a timeline containing all our MediaPoolItem s for the current resolution in the loop. We then activate that timeline and set the timeline resolution to be the same as the clip's resolutions, to avoid any letterboxing. def generate_premiere_proxies ( input_dir , output_dir , proxyfactor ): ... render_ids = [] for key in clips_res . keys (): ... media_pool . create_timeline_from_clips ( res_folder . name , # (1) res_folder . clips ) timeline = project . timeline timeline . set_setting ( \"useCustomSettings\" , \"1\" ) # (2) timeline . set_setting ( \"timelineResolutionWidth\" , res_x ) timeline . set_setting ( \"timelineResolutionHeight\" , res_y ) This is for the created timeline name. We're using the Folder name from before, which is set to be a string representing the resolution. This allows us to set custom resolutions and framerates for timelines more easily through the Python API, without having to mess with the Project Settings. For the next step, we need to set our render settings. Let's calculate our desired rendered resolution using our provided proxyfactor , set our render format/codec and output directory. def generate_premiere_proxies ( input_dir , output_dir , proxyfactor ): ... render_ids = [] for key in clips_res . keys (): ... project . set_render_format_and_codec ( \"mp4\" , \"H264\" ) render_settings = { # (1) \"FormatWidth\" : ( int ( res_x ) // proxyfactor ), # (2) \"FormatHeight\" : ( int ( res_y ) // proxyfactor ), \"TargetDir\" : output_dir , } project . set_render_settings ( render_settings ) The valid render settings that you can change are available at Project.set_render_settings() The \\\\ floor operator ensures we get an int back and not a float Warning If for any reason your render resolution ends up being an odd number, DaVinci will throw an error in the GUI and your script won't be able to continue. Now we're almost done! Just add the current timeline and render settings to the render queue, and append it to our render_ids list def generate_premiere_proxies ( input_dir , output_dir , proxyfactor ): ... render_ids = [] for key in clips_res . keys (): ... render_id = project . add_renderjob () render_ids . append ( render_id ) return render_ids","title":"Creating render jobs"},{"location":"examples/premiereproxies/#render-time","text":"Now we can get our job_ids and render them out!: job_ids = generate_premiere_proxies ( \"Path/To/Folder/With/Clips\" , \"Path/To/Output/Folder, proxyfactor = 2 , ) project . render ( job_ids ) Resolve will start rendering all our timelines with our clips, and in the end we'll have proxies ready to be edited by Premiere. Check out the full code here , with some extra functionality at the end which just prints out a nice message on render times left and total render time.","title":"Render time!"}]}