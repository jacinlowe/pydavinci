{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pydavinci A lightly opinionated DaVinci Resolve Python API wrapper Provides auto completion, type hints and great API reference documentation. I really just wanted auto completion in the IDE and to program transcoding RAW formats Install pydavinci Install via pip using a Python 3.6 environment pip install pydavinci Now, with Davinci Resolve open, we just need to import it! from pydavinci import davinci resolve = davinci . Resolve () Examples and documentation Check out the usage examples Or go deep in the documentation Installation requirements and guidelines pydavinci only works with Python 3.6.* , as that's a requirement on DaVinci Resolve's part. For launching scripts externally, you also need the Studio version. If you're working with the built-in Davinci Resolve Python console, you need to install pydavinci for the Python interpreter that's used by Davinci's console. For avoiding conflicts when using inside the embedded console, don't use resolve as the entry point variable, as that's reserved by the console. Example of suggested usage: Davinci Resolve v18 beta For the newer DaVinci Resolve v18, currently in beta, newer Python installations are supported. If you want to try out pydavinci with new Python versions for Resolve v18, use pip with the --ignore-requires-python flag. Note that while I did some quick tests, I can't guarantee everything works on Resolve v18 beta. Full testing will become available as further betas come through, and will be supported fully on the official release. Launching scripts externally (Studio version) For pydavinci to work by launching scripts outside the embedded console, make sure external scripting is set to Local in Settings -> System -> General To-do and contributing Contributors are always welcome! I currently have a few things I want to change, some of them are: Document all possible values of get_setting and set_setting Add a better way of interfacing with the whole get_setting and set_setting methods using a proxy class or something to that effect Deal with markers in a better way Auto launch Resolve when it's not open - I've ran into some issues while trying to connect to the C extension right after launching it, a dirty way to do it is to just implement a time.sleep before trying to import the fusionscript module, otherwise we'll need to create another entrypoint to the api for launching the process and then signaling when it's ready If you want to contribute feel free to open a pull request!","title":"Home"},{"location":"#install-pydavinci","text":"Install via pip using a Python 3.6 environment pip install pydavinci Now, with Davinci Resolve open, we just need to import it! from pydavinci import davinci resolve = davinci . Resolve ()","title":"Install pydavinci"},{"location":"#examples-and-documentation","text":"Check out the usage examples Or go deep in the documentation","title":"Examples and documentation"},{"location":"#installation-requirements-and-guidelines","text":"pydavinci only works with Python 3.6.* , as that's a requirement on DaVinci Resolve's part. For launching scripts externally, you also need the Studio version. If you're working with the built-in Davinci Resolve Python console, you need to install pydavinci for the Python interpreter that's used by Davinci's console. For avoiding conflicts when using inside the embedded console, don't use resolve as the entry point variable, as that's reserved by the console. Example of suggested usage:","title":"Installation requirements and guidelines"},{"location":"#davinci-resolve-v18-beta","text":"For the newer DaVinci Resolve v18, currently in beta, newer Python installations are supported. If you want to try out pydavinci with new Python versions for Resolve v18, use pip with the --ignore-requires-python flag. Note that while I did some quick tests, I can't guarantee everything works on Resolve v18 beta. Full testing will become available as further betas come through, and will be supported fully on the official release.","title":"Davinci Resolve v18 beta"},{"location":"#launching-scripts-externally-studio-version","text":"For pydavinci to work by launching scripts outside the embedded console, make sure external scripting is set to Local in Settings -> System -> General","title":"Launching scripts externally (Studio version)"},{"location":"#to-do-and-contributing","text":"Contributors are always welcome! I currently have a few things I want to change, some of them are: Document all possible values of get_setting and set_setting Add a better way of interfacing with the whole get_setting and set_setting methods using a proxy class or something to that effect Deal with markers in a better way Auto launch Resolve when it's not open - I've ran into some issues while trying to connect to the C extension right after launching it, a dirty way to do it is to just implement a time.sleep before trying to import the fusionscript module, otherwise we'll need to create another entrypoint to the api for launching the process and then signaling when it's ready If you want to contribute feel free to open a pull request!","title":"To-do and contributing"},{"location":"folder/","text":"Attributes Folder . clips -> List [ MediaPoolItem ] property Gets all clips Returns: Type Description List [ MediaPoolItem ] list of clips Folder . name -> str property Gets folder name Returns: Name Type Description name str folder name Folder . subfolders -> List [ 'Folder' ] property Gets subfolders Returns: Name Type Description subfolders List [ Folder ] subfolders Functions","title":"Folder"},{"location":"folder/#pydavinci.wrappers.folder.Folder-attributes","text":"","title":"Attributes"},{"location":"folder/#pydavinci.wrappers.folder.Folder.clips","text":"Gets all clips Returns: Type Description List [ MediaPoolItem ] list of clips","title":"clips"},{"location":"folder/#pydavinci.wrappers.folder.Folder.name","text":"Gets folder name Returns: Name Type Description name str folder name","title":"name"},{"location":"folder/#pydavinci.wrappers.folder.Folder.subfolders","text":"Gets subfolders Returns: Name Type Description subfolders List [ Folder ] subfolders","title":"subfolders"},{"location":"folder/#pydavinci.wrappers.folder.Folder-functions","text":"","title":"Functions"},{"location":"marker/","text":"Attributes Marker . frameid -> int property writable Gets or changes this Marker 's frameid Marker . customdata -> str property writable Gets or changes this Marker 's customdata Marker . name -> str property writable Gets or changes this Marker 's name Marker . color -> str property writable Gets or changes this Marker 's color Marker . duration -> int property writable Gets or changes this Marker 's duration Marker . note -> str property writable Gets or changes this Marker 's note Functions Marker . delete () -> None Deletes this Marker","title":"Marker"},{"location":"marker/#pydavinci.wrappers.marker.Marker-attributes","text":"","title":"Attributes"},{"location":"marker/#pydavinci.wrappers.marker.Marker.frameid","text":"Gets or changes this Marker 's frameid","title":"frameid"},{"location":"marker/#pydavinci.wrappers.marker.Marker.customdata","text":"Gets or changes this Marker 's customdata","title":"customdata"},{"location":"marker/#pydavinci.wrappers.marker.Marker.name","text":"Gets or changes this Marker 's name","title":"name"},{"location":"marker/#pydavinci.wrappers.marker.Marker.color","text":"Gets or changes this Marker 's color","title":"color"},{"location":"marker/#pydavinci.wrappers.marker.Marker.duration","text":"Gets or changes this Marker 's duration","title":"duration"},{"location":"marker/#pydavinci.wrappers.marker.Marker.note","text":"Gets or changes this Marker 's note","title":"note"},{"location":"marker/#pydavinci.wrappers.marker.Marker-functions","text":"","title":"Functions"},{"location":"marker/#pydavinci.wrappers.marker.Marker.delete","text":"Deletes this Marker","title":"delete()"},{"location":"markercollection/","text":"Attributes markers . all -> List [ 'Marker' ] property Returns a list with all Marker 's Returns: Type Description List ['Marker'] (List[Marker]) Functions markers . add ( frameid : int , color : str , name : str , * , note : str = '' , duration : int = 1 , customdata : str = '' , overwrite : bool = False ) -> Optional [ 'Marker' ] Adds a marker. customdata is a str that can be used for programatically setting and searching for markers. It's not exposed to the GUI. Parameters: Name Type Description Default frameid int frame for marker to be inserted at required color str marker color required name str marker name required note str marker note. Defaults to empty. '' duration int marker duration. Defaults to 1 frame. 1 customdata str custom user data. Defaults to empty. '' overwrite bool set to True if you want to overwrite an existing marker at that frameid. False Returns: Name Type Description bool Optional ['Marker'] Marker if successful markers . find ( needle : str ) -> Optional [ 'Marker' ] Finds the first marker that matches needle for the Marker's note , name or customdata Returns: Type Description Marker first marker found with matching query markers . find_all ( needle : str ) -> Optional [ List [ 'Marker' ]] Finds all markers that match needle for the Marker's note , name or customdata Returns: Type Description Optional [ List [ Marker ]] all markers found or if none found, returns None markers . get_custom ( customdata : str ) -> Dict [ Any , Any ] Gets custom marker by customdata Parameters: Name Type Description Default customdata str custom data string required Returns: Name Type Description dict Dict [ Any , Any ] dict with marker data markers . delete ( * , frameid : int = 0 , color : str = '' , customdata : str = '' ) -> bool Deletes marker using frameid , color or customdata Parameters: Name Type Description Default frameid int frameid to use for choosing which markers to delete 0 color str color to use for choosing which markers to delete '' customdata str custom data to use for choosing which markers to delete '' Raises: Type Description ValueError no valid params provided Returns: Name Type Description bool bool True if successful, False otherwise Deleting Markers When selecting by frameid , will delete single marker When selecting by color , will delete all markers with provided color When selecting by customdata , will delete first marker with matching custom data markers . delete_all () -> None Deletes all markers markers . fetch () -> None Fetch all markers from Davinci Resolve and updates MarkerCollection s internal cache. You probably won't need to use this. Why not You would only use this if during the middle of the script execution a user manually added a marker. Otherwise, a MarkerCollection knows about all the markers it has deleted, added or updated, and .fetch() is run on the class initialization.","title":"Marker Collection"},{"location":"markercollection/#pydavinci.wrappers.marker.MarkerCollection-attributes","text":"","title":"Attributes"},{"location":"markercollection/#pydavinci.wrappers.marker.MarkerCollection.all","text":"Returns a list with all Marker 's Returns: Type Description List ['Marker'] (List[Marker])","title":"all"},{"location":"markercollection/#pydavinci.wrappers.marker.MarkerCollection-functions","text":"","title":"Functions"},{"location":"markercollection/#pydavinci.wrappers.marker.MarkerCollection.add","text":"Adds a marker. customdata is a str that can be used for programatically setting and searching for markers. It's not exposed to the GUI. Parameters: Name Type Description Default frameid int frame for marker to be inserted at required color str marker color required name str marker name required note str marker note. Defaults to empty. '' duration int marker duration. Defaults to 1 frame. 1 customdata str custom user data. Defaults to empty. '' overwrite bool set to True if you want to overwrite an existing marker at that frameid. False Returns: Name Type Description bool Optional ['Marker'] Marker if successful","title":"add()"},{"location":"markercollection/#pydavinci.wrappers.marker.MarkerCollection.find","text":"Finds the first marker that matches needle for the Marker's note , name or customdata Returns: Type Description Marker first marker found with matching query","title":"find()"},{"location":"markercollection/#pydavinci.wrappers.marker.MarkerCollection.find_all","text":"Finds all markers that match needle for the Marker's note , name or customdata Returns: Type Description Optional [ List [ Marker ]] all markers found or if none found, returns None","title":"find_all()"},{"location":"markercollection/#pydavinci.wrappers.marker.MarkerCollection.get_custom","text":"Gets custom marker by customdata Parameters: Name Type Description Default customdata str custom data string required Returns: Name Type Description dict Dict [ Any , Any ] dict with marker data","title":"get_custom()"},{"location":"markercollection/#pydavinci.wrappers.marker.MarkerCollection.delete","text":"Deletes marker using frameid , color or customdata Parameters: Name Type Description Default frameid int frameid to use for choosing which markers to delete 0 color str color to use for choosing which markers to delete '' customdata str custom data to use for choosing which markers to delete '' Raises: Type Description ValueError no valid params provided Returns: Name Type Description bool bool True if successful, False otherwise Deleting Markers When selecting by frameid , will delete single marker When selecting by color , will delete all markers with provided color When selecting by customdata , will delete first marker with matching custom data","title":"delete()"},{"location":"markercollection/#pydavinci.wrappers.marker.MarkerCollection.delete_all","text":"Deletes all markers","title":"delete_all()"},{"location":"markercollection/#pydavinci.wrappers.marker.MarkerCollection.fetch","text":"Fetch all markers from Davinci Resolve and updates MarkerCollection s internal cache. You probably won't need to use this. Why not You would only use this if during the middle of the script execution a user manually added a marker. Otherwise, a MarkerCollection knows about all the markers it has deleted, added or updated, and .fetch() is run on the class initialization.","title":"fetch()"},{"location":"mediapool/","text":"Attributes MediaPool . root_folder -> 'Folder' property Gets media pool root folder Returns: Type Description Folder media pool root folder MediaPool . current_folder -> 'Folder' property Gets current mediapool folder Returns: Type Description Folder current mediapool folder Functions MediaPool . add_subfolder ( folder_name : str , parent_folder : 'Folder' ) -> 'Folder' Adds subfolder folder_name into parent_folder Parameters: Name Type Description Default folder_name str subfolder name required parent_folder Folder parent folder object required Returns: Type Description Folder created subfolder MediaPool . create_empty_timeline ( timeline_name : str ) -> 'Timeline' Creates empty timeline in current folder Parameters: Name Type Description Default timeline_name str timeline name required Returns: Type Description Timeline created timeline MediaPool . append_to_timeline ( clips : List [ 'MediaPoolItem' ]) -> List [ 'TimelineItem' ] Appends a list of MediaPoolItem s to current active timeline Parameters: Name Type Description Default clips List [ MediaPoolItem ] list of MediaPoolItem s to append required Returns: Type Description List [ TimelineItem ] list of inserted TimelineItem s MediaPool . create_timeline_from_clips ( name : str , clips : List [ 'MediaPoolItem' ]) -> 'Timeline' Creates timeline name from clips Parameters: Name Type Description Default name str new timeline name required clips List [ MediaPoolItem ] list of MediaPoolItem s to use for creating the timeline required Returns: Type Description Timeline created timeline MediaPool . import_timeline_fromfile ( path : str , options : Optional [ Dict [ Any , Any ]] = None ) -> 'Timeline' Imports a timeline from path with options : options = { \"timelineName\" : str , # specifies the name of the timeline to be created \"importSourceClips\" : bool , # specifies whether source clips should be imported, True by default \"sourceClipsPath\" : str , # specifies a filesystem path to search for source clips if the media # is inaccessible in their original path and if \"importSourceClips\" is True \"sourceClipsFolders\" : List [ Folder ] # to search for source clips if the media is not present in current folder # and if \"importSourceClips\" is False \"interlaceProcessing\" : bool , # specifies whether to enable interlace processing on the imported # timeline being created. valid only for AAF import } Parameters: Name Type Description Default path str timeline file path required options dict Dict with import options. Defaults to None . None Returns: Type Description Timeline created timeline MediaPool . delete_timelines ( timelines : List [ 'Timeline' ]) -> bool Deletes timelines Parameters: Name Type Description Default timelines List [ Timeline ] list of timelines to be deleted required Returns: Name Type Description bool bool True if successful, False otherwise Info If you want to delete only one timeline, you can wrap it in a single element list. MediaPool . set_current_folder ( folder : 'Folder' ) -> bool Sets current mediapool folder Parameters: Name Type Description Default folder Folder desired Folder required Returns: Name Type Description bool bool True if successful, False otherwise MediaPool . delete_clips ( clips : List [ 'MediaPoolItem' ]) -> bool Delete clips Parameters: Name Type Description Default clips List [ MediaPoolItem ] list of MediaPoolItem s to be deleted required Returns: Name Type Description bool bool True if successful, False otherwise MediaPool . delete_folders ( folders : List [ 'Folder' ]) -> bool Delete folders Parameters: Name Type Description Default folders List [ Folder ] list of Folder s to be deleted required Returns: Name Type Description bool bool True if successful, False otherwise MediaPool . move_clips ( clips : List [ 'MediaPoolItem' ], folder : 'Folder' ) -> bool Moves clips inside current active folder to folder Parameters: Name Type Description Default clips List [ MediaPoolItem ] list of MediaPoolItem s on current folder required folder Folder destination folder required Returns: Name Type Description bool bool True if successful, False otherwise MediaPool . move_folders ( folders : List [ 'Folder' ], target_folder : 'Folder' ) -> bool Move folders to target_folder Parameters: Name Type Description Default folders List [ Folder ] List of folders to be moved. If you want to only use one folder, wrap it in a list. required target_folder Folder target Folder required Returns: Name Type Description bool bool True if successful, False otherwise MediaPool . clip_mattes ( clip : 'MediaPoolItem' ) -> List [ str ] Gets paths of clip mattes from clip Parameters: Name Type Description Default clip MediaPoolItem clip to get mattes from required Returns: Type Description List [ str ] list of file paths associated with clip 's mattes MediaPool . timeline_mattes ( folder : 'Folder' ) -> List [ 'MediaPoolItem' ] Gets timeline mattes inside folder Parameters: Name Type Description Default folder Folder folder to get timeline mattes from required Returns: Type Description List [ MediaPoolItem ] list of timeline mattes MediaPool . delete_mattes_by_path ( clip : 'MediaPoolItem' , path : List [ str ]) -> bool Delete mattes based on their file paths. Parameters: Name Type Description Default clip MediaPoolItem clip to have mattes deleted required path List [ str ] list of matte paths required Returns: Name Type Description bool bool description MediaPool . relink_clips ( clips : List [ 'MediaPoolItem' ], parent_folder : str ) -> bool Update the folder location of specified media pool clips with the specified folder path. Parameters: Name Type Description Default clips List [ MediaPoolItem ] MediaPoolItem s to relink required parent_folder str new parent folder required Returns: Name Type Description bool bool True if successful, False otherwise MediaPool . unlink_clips ( clips : List [ 'MediaPoolItem' ]) -> bool Unlink clips Parameters: Name Type Description Default clips List [ MediaPoolItem ] clips to be made offline required Returns: Name Type Description bool bool True if successful, False otherwise MediaPool . import_media ( paths : List [ str ]) -> List [ 'MediaPoolItem' ] Import media from paths Parameters: Name Type Description Default paths List [ str ] list of paths containing the media required Returns: Type Description List [ MediaPoolItem ] list of imported MediaPoolItem s Image Sequences Doesn't support image sequences yet. MediaPool . export_metadata ( file_name : str , clips : Optional [ List [ 'MediaPoolItem' ]] = None ) -> bool Exports metadata of specified clips to file_name.csv . If no clips are specified, all clips from MediaPool will be used. Parameters: Name Type Description Default file_name str description required clips List [ MediaPoolItem ] list of clips to be processed, defaults to None None Returns: Name Type Description bool bool True if successful, False otherwise","title":"MediaPool"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool-attributes","text":"","title":"Attributes"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.root_folder","text":"Gets media pool root folder Returns: Type Description Folder media pool root folder","title":"root_folder"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.current_folder","text":"Gets current mediapool folder Returns: Type Description Folder current mediapool folder","title":"current_folder"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool-functions","text":"","title":"Functions"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.add_subfolder","text":"Adds subfolder folder_name into parent_folder Parameters: Name Type Description Default folder_name str subfolder name required parent_folder Folder parent folder object required Returns: Type Description Folder created subfolder","title":"add_subfolder()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.create_empty_timeline","text":"Creates empty timeline in current folder Parameters: Name Type Description Default timeline_name str timeline name required Returns: Type Description Timeline created timeline","title":"create_empty_timeline()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.append_to_timeline","text":"Appends a list of MediaPoolItem s to current active timeline Parameters: Name Type Description Default clips List [ MediaPoolItem ] list of MediaPoolItem s to append required Returns: Type Description List [ TimelineItem ] list of inserted TimelineItem s","title":"append_to_timeline()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.create_timeline_from_clips","text":"Creates timeline name from clips Parameters: Name Type Description Default name str new timeline name required clips List [ MediaPoolItem ] list of MediaPoolItem s to use for creating the timeline required Returns: Type Description Timeline created timeline","title":"create_timeline_from_clips()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.import_timeline_fromfile","text":"Imports a timeline from path with options : options = { \"timelineName\" : str , # specifies the name of the timeline to be created \"importSourceClips\" : bool , # specifies whether source clips should be imported, True by default \"sourceClipsPath\" : str , # specifies a filesystem path to search for source clips if the media # is inaccessible in their original path and if \"importSourceClips\" is True \"sourceClipsFolders\" : List [ Folder ] # to search for source clips if the media is not present in current folder # and if \"importSourceClips\" is False \"interlaceProcessing\" : bool , # specifies whether to enable interlace processing on the imported # timeline being created. valid only for AAF import } Parameters: Name Type Description Default path str timeline file path required options dict Dict with import options. Defaults to None . None Returns: Type Description Timeline created timeline","title":"import_timeline_fromfile()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.delete_timelines","text":"Deletes timelines Parameters: Name Type Description Default timelines List [ Timeline ] list of timelines to be deleted required Returns: Name Type Description bool bool True if successful, False otherwise Info If you want to delete only one timeline, you can wrap it in a single element list.","title":"delete_timelines()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.set_current_folder","text":"Sets current mediapool folder Parameters: Name Type Description Default folder Folder desired Folder required Returns: Name Type Description bool bool True if successful, False otherwise","title":"set_current_folder()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.delete_clips","text":"Delete clips Parameters: Name Type Description Default clips List [ MediaPoolItem ] list of MediaPoolItem s to be deleted required Returns: Name Type Description bool bool True if successful, False otherwise","title":"delete_clips()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.delete_folders","text":"Delete folders Parameters: Name Type Description Default folders List [ Folder ] list of Folder s to be deleted required Returns: Name Type Description bool bool True if successful, False otherwise","title":"delete_folders()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.move_clips","text":"Moves clips inside current active folder to folder Parameters: Name Type Description Default clips List [ MediaPoolItem ] list of MediaPoolItem s on current folder required folder Folder destination folder required Returns: Name Type Description bool bool True if successful, False otherwise","title":"move_clips()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.move_folders","text":"Move folders to target_folder Parameters: Name Type Description Default folders List [ Folder ] List of folders to be moved. If you want to only use one folder, wrap it in a list. required target_folder Folder target Folder required Returns: Name Type Description bool bool True if successful, False otherwise","title":"move_folders()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.clip_mattes","text":"Gets paths of clip mattes from clip Parameters: Name Type Description Default clip MediaPoolItem clip to get mattes from required Returns: Type Description List [ str ] list of file paths associated with clip 's mattes","title":"clip_mattes()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.timeline_mattes","text":"Gets timeline mattes inside folder Parameters: Name Type Description Default folder Folder folder to get timeline mattes from required Returns: Type Description List [ MediaPoolItem ] list of timeline mattes","title":"timeline_mattes()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.delete_mattes_by_path","text":"Delete mattes based on their file paths. Parameters: Name Type Description Default clip MediaPoolItem clip to have mattes deleted required path List [ str ] list of matte paths required Returns: Name Type Description bool bool description","title":"delete_mattes_by_path()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.relink_clips","text":"Update the folder location of specified media pool clips with the specified folder path. Parameters: Name Type Description Default clips List [ MediaPoolItem ] MediaPoolItem s to relink required parent_folder str new parent folder required Returns: Name Type Description bool bool True if successful, False otherwise","title":"relink_clips()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.unlink_clips","text":"Unlink clips Parameters: Name Type Description Default clips List [ MediaPoolItem ] clips to be made offline required Returns: Name Type Description bool bool True if successful, False otherwise","title":"unlink_clips()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.import_media","text":"Import media from paths Parameters: Name Type Description Default paths List [ str ] list of paths containing the media required Returns: Type Description List [ MediaPoolItem ] list of imported MediaPoolItem s Image Sequences Doesn't support image sequences yet.","title":"import_media()"},{"location":"mediapool/#pydavinci.wrappers.mediapool.MediaPool.export_metadata","text":"Exports metadata of specified clips to file_name.csv . If no clips are specified, all clips from MediaPool will be used. Parameters: Name Type Description Default file_name str description required clips List [ MediaPoolItem ] list of clips to be processed, defaults to None None Returns: Name Type Description bool bool True if successful, False otherwise","title":"export_metadata()"},{"location":"mediapoolitem/","text":"MediaPoolItem . markers property Returns the Marker Collection for this MediaPoolItem . Attributes MediaPoolItem . name -> str property Returns: Type Description str MediaPoolItem name MediaPoolItem . media_id -> str property Returns: Type Description str MediaPoolItem UUID MediaPoolItem . flags -> List [ str ] property Gets flag list Returns: Type Description List [ str ] list of valid flag colors MediaPoolItem . color -> str property writable Gets or sets clip color Parameters: Name Type Description Default color str new clip color required Returns: Type Description str clip color MediaPoolItem . properties -> Union [ str , Dict [ Any , Any ]] property Gets all clip properties Returns: Name Type Description dict Union [ str , Dict [ Any , Any ]] dict with clip properties Functions MediaPoolItem . get_metadata ( metadata_key : Optional [ str ] = None ) -> Union [ str , Dict [ Any , Any ]] Gets metadata metadata_key for MediaPoolItem . If no metadata_key is provided, returns a Dict with all available metadata. Can return an empty dict if there's no metadata. Parameters: Name Type Description Default metadata_key Optional [ Any ] metadata key None Returns: Type Description Union [ str , Dict [ Any , Any ]] Dict or str corresponding to metadata_key MediaPoolItem . set_metadata ( meta_dict : Any ) -> bool Sets metadata with meta_dict : meta_dict = { metadata_key : metadata value } It's recommended you validate which metadata you wan't to change first by using MediaPoolItem.get_metadata() and getting a dict with all the metadata to see which one you want to alter. This will probably change for the better for version 1.0 Parameters: Name Type Description Default meta_dict dict dict with metadata to be set required Returns: Name Type Description bool bool True if successful, False otherwise MediaPoolItem . add_flag ( color : str ) -> bool Adds a flag Parameters: Name Type Description Default color str flag color required Returns: Name Type Description bool bool True if successful, False otherwise MediaPoolItem . clear_flags ( color : str = 'All' ) -> bool Clears flags Parameters: Name Type Description Default color str Clears flag by color . If none provided, defaults to \"All\" which clears all flags. 'All' Returns: Type Description bool True if successful, False otherwise MediaPoolItem . clear_color () -> bool Clears clip color Returns: Name Type Description bool bool True if successful, False otherwise MediaPoolItem . set_property ( name : str , value : Union [ str , int , float ]) -> bool Sets property Parameters: Name Type Description Default name str property name required value Union [ str , int , float ] property value required Returns: Name Type Description bool bool True if successful, False otherwise MediaPoolItem . link_proxy ( path : str ) -> bool Links media located at path to this MediaPoolItem Parameters: Name Type Description Default path str absolute path to proxy media required Returns: Name Type Description bool bool True if successful, False otherwise MediaPoolItem . unlink_proxy () -> bool Unlinks proxy media of this MediaPoolItem Returns: Name Type Description bool bool True if successful, False otherwise MediaPoolItem . replace_clip ( path : str ) -> bool Replaces the underlying asset and metadata of MediaPoolItem with the specified absolute clip path. Parameters: Name Type Description Default path str path to clip required Returns: Name Type Description bool bool True if successful, False otherwise","title":"MediaPool Item"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem-attributes","text":"","title":"Attributes"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.name","text":"Returns: Type Description str MediaPoolItem name","title":"name"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.media_id","text":"Returns: Type Description str MediaPoolItem UUID","title":"media_id"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.flags","text":"Gets flag list Returns: Type Description List [ str ] list of valid flag colors","title":"flags"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.color","text":"Gets or sets clip color Parameters: Name Type Description Default color str new clip color required Returns: Type Description str clip color","title":"color"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.properties","text":"Gets all clip properties Returns: Name Type Description dict Union [ str , Dict [ Any , Any ]] dict with clip properties","title":"properties"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem-functions","text":"","title":"Functions"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.get_metadata","text":"Gets metadata metadata_key for MediaPoolItem . If no metadata_key is provided, returns a Dict with all available metadata. Can return an empty dict if there's no metadata. Parameters: Name Type Description Default metadata_key Optional [ Any ] metadata key None Returns: Type Description Union [ str , Dict [ Any , Any ]] Dict or str corresponding to metadata_key","title":"get_metadata()"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.set_metadata","text":"Sets metadata with meta_dict : meta_dict = { metadata_key : metadata value } It's recommended you validate which metadata you wan't to change first by using MediaPoolItem.get_metadata() and getting a dict with all the metadata to see which one you want to alter. This will probably change for the better for version 1.0 Parameters: Name Type Description Default meta_dict dict dict with metadata to be set required Returns: Name Type Description bool bool True if successful, False otherwise","title":"set_metadata()"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.add_flag","text":"Adds a flag Parameters: Name Type Description Default color str flag color required Returns: Name Type Description bool bool True if successful, False otherwise","title":"add_flag()"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.clear_flags","text":"Clears flags Parameters: Name Type Description Default color str Clears flag by color . If none provided, defaults to \"All\" which clears all flags. 'All' Returns: Type Description bool True if successful, False otherwise","title":"clear_flags()"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.clear_color","text":"Clears clip color Returns: Name Type Description bool bool True if successful, False otherwise","title":"clear_color()"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.set_property","text":"Sets property Parameters: Name Type Description Default name str property name required value Union [ str , int , float ] property value required Returns: Name Type Description bool bool True if successful, False otherwise","title":"set_property()"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.link_proxy","text":"Links media located at path to this MediaPoolItem Parameters: Name Type Description Default path str absolute path to proxy media required Returns: Name Type Description bool bool True if successful, False otherwise","title":"link_proxy()"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.unlink_proxy","text":"Unlinks proxy media of this MediaPoolItem Returns: Name Type Description bool bool True if successful, False otherwise","title":"unlink_proxy()"},{"location":"mediapoolitem/#pydavinci.wrappers.mediapoolitem.MediaPoolItem.replace_clip","text":"Replaces the underlying asset and metadata of MediaPoolItem with the specified absolute clip path. Parameters: Name Type Description Default path str path to clip required Returns: Name Type Description bool bool True if successful, False otherwise","title":"replace_clip()"},{"location":"mediastorage/","text":"Attributes MediaStorage . mounted_volumes -> List [ Any ] property Gets list of OS mounted volumes Returns: Name Type Description list List [ Any ] list of volumes Functions MediaStorage . get_subfolders ( folder_path : str ) -> List [ str ] Gets subfolders on folder_path Parameters: Name Type Description Default folder_path str parent folder required Returns: Type Description List [ str ] List[str]: list of subfolders MediaStorage . get_file_list ( folder_path : str ) -> List [ str ] Gets list of file on folder_path Parameters: Name Type Description Default folder_path str parent folder required Returns: Type Description List [ str ] List[str]: list of files in parent_folder MediaStorage . reveal_in_storage ( path : str ) -> bool Opens path in media storage Parameters: Name Type Description Default path str path required Returns: Name Type Description None bool None MediaStorage . add_clip_mattes ( mediapool_item : 'MediaPoolItem' , paths : List [ str ], stereo_eye : str ) -> bool Adds clip mattes from path in mediapool_item Parameters: Name Type Description Default mediapool_item MediaPoolItem a MediaPoolItem object required paths Union [ List [ str ], str ] A list of path strings or a single path string required Returns: Name Type Description bool bool True if successful, False otherwise MediaStorage . add_timelilne_mattes ( paths : List [ str ]) -> List [ 'MediaPoolItem' ] Adds timeline mattes into media pool Parameters: Name Type Description Default paths Union [ List [ str ], str ] a list of path strings or a single path string to a timeline matte required Returns: Type Description List ['MediaPoolItem'] List[MediaPoolItem]: list of timeline mattes MediaPoolItem s MediaStorage . addclips_to_mediapool ( item : List [ str ]) -> List [ 'MediaPoolItem' ] Adds clips to media pool Parameters: Name Type Description Default item List [ str ] a list of media paths or folders to add to media pool required Returns: Type Description List ['MediaPoolItem'] List[MediaPoolItem]: list of added MediaPoolItem s Info Even if you only added one clip, the returned MediaPoolItem will be inside a list. Access it directly by slicing it with the 0 index.","title":"MediaStorage"},{"location":"mediastorage/#pydavinci.wrappers.mediastorage.MediaStorage-attributes","text":"","title":"Attributes"},{"location":"mediastorage/#pydavinci.wrappers.mediastorage.MediaStorage.mounted_volumes","text":"Gets list of OS mounted volumes Returns: Name Type Description list List [ Any ] list of volumes","title":"mounted_volumes"},{"location":"mediastorage/#pydavinci.wrappers.mediastorage.MediaStorage-functions","text":"","title":"Functions"},{"location":"mediastorage/#pydavinci.wrappers.mediastorage.MediaStorage.get_subfolders","text":"Gets subfolders on folder_path Parameters: Name Type Description Default folder_path str parent folder required Returns: Type Description List [ str ] List[str]: list of subfolders","title":"get_subfolders()"},{"location":"mediastorage/#pydavinci.wrappers.mediastorage.MediaStorage.get_file_list","text":"Gets list of file on folder_path Parameters: Name Type Description Default folder_path str parent folder required Returns: Type Description List [ str ] List[str]: list of files in parent_folder","title":"get_file_list()"},{"location":"mediastorage/#pydavinci.wrappers.mediastorage.MediaStorage.reveal_in_storage","text":"Opens path in media storage Parameters: Name Type Description Default path str path required Returns: Name Type Description None bool None","title":"reveal_in_storage()"},{"location":"mediastorage/#pydavinci.wrappers.mediastorage.MediaStorage.add_clip_mattes","text":"Adds clip mattes from path in mediapool_item Parameters: Name Type Description Default mediapool_item MediaPoolItem a MediaPoolItem object required paths Union [ List [ str ], str ] A list of path strings or a single path string required Returns: Name Type Description bool bool True if successful, False otherwise","title":"add_clip_mattes()"},{"location":"mediastorage/#pydavinci.wrappers.mediastorage.MediaStorage.add_timelilne_mattes","text":"Adds timeline mattes into media pool Parameters: Name Type Description Default paths Union [ List [ str ], str ] a list of path strings or a single path string to a timeline matte required Returns: Type Description List ['MediaPoolItem'] List[MediaPoolItem]: list of timeline mattes MediaPoolItem s","title":"add_timelilne_mattes()"},{"location":"mediastorage/#pydavinci.wrappers.mediastorage.MediaStorage.addclips_to_mediapool","text":"Adds clips to media pool Parameters: Name Type Description Default item List [ str ] a list of media paths or folders to add to media pool required Returns: Type Description List ['MediaPoolItem'] List[MediaPoolItem]: list of added MediaPoolItem s Info Even if you only added one clip, the returned MediaPoolItem will be inside a list. Access it directly by slicing it with the 0 index.","title":"addclips_to_mediapool()"},{"location":"project/","text":"Attributes Project . settings -> 'ProjectSettings' property Returns the ProjectSettings interface. Project . mediapool -> 'MediaPool' property Returns the MediaPool object. Returns: Type Description MediaPool Media Storage object Project . timeline_count -> int property Get total timeline count on current project Returns: Type Description int timeline count Project . name -> str property writable Gets or sets current project name Returns: Type Description str project name Project . presets -> List [ str ] property Gets a list of available project presets Returns: Type Description List [ str ] project presets Project . render_jobs -> List [ str ] property Gets current list of render jobs Returns: Name Type Description list List [ str ] render job list Project . render_presets -> List [ str ] property Gets available render presets list Returns: Name Type Description list List [ str ] available render presets list Project . render_formats -> Dict [ Any , Any ] property Gets all possible render formats. Returns: Name Type Description dict Dict [ Any , Any ] dict with render formats Project . current_render_format_and_codec -> Dict [ Any , Any ] property Gets current render format and codec. Returns: Name Type Description dict Dict [ Any , Any ] dict with current render format and codec Project . render_mode -> str property writable Gets or sets current render mode. single for single clip and individual for individual clips. Returns: Type Description str render mode single or individual Project . timeline -> 'Timeline' property Returns current Timeline object Returns: Name Type Description Timeline Timeline timeline object Functions Project . set_preset ( preset_name : str ) -> bool Activates preset_name Parameters: Name Type Description Default preset_name str preset name required Returns: Name Type Description bool bool True if successful, False otherwise Project . add_renderjob ( block : bool = True ) -> str Adds current render settings to a render job. If there are already rendered jobs in the render queue and you're executing a lot of commands, there's a bug on the Davinci API that there's a chance it will return an empty string instead of the job ID. block blocks the program until we get a job id back from Davinci Resolve. It's True by default. Returns: Name Type Description str str render job id Project . delete_renderjob ( job_id : str ) -> bool Deletes render job job_id Parameters: Name Type Description Default job_id str render job id required Returns: Name Type Description bool bool True if successful, False otherwise Project . delete_all_renderjobs () -> bool Deletes all renderjobs Returns: Name Type Description bool bool True if successful, False otherwise Project . render ( job_ids : Optional [ List [ str ]] = None , interactive : bool = True ) -> bool Render jobs Parameters: Name Type Description Default job_ids Union [None, List [ str ]] Renders provided list of job ids . If None provided, render all jobs in queue. Defaults to None . None interactive bool Whether to use interactive mode. When set to True , enables error feedback in the UI during rendering. True Returns: Name Type Description bool bool True if successful, False otherwise Project . stop_render () -> None Stops all rendering. Returns: Name Type Description None None None Project . render_status ( job_id : str ) -> Dict [ Any , Union [ str , int ]] Gets render status on job_id Parameters: Name Type Description Default job_id str job id required Returns: Name Type Description dict Dict [ Any , Union [ str , int ]] dictionary with render status Render Status The dictionary returned looks like this when rendering: { 'JobStatus' : 'Rendering' , 'CompletionPercentage' : 92 , 'EstimatedTimeRemainingInMs' : 1000 } And like this when the render on the provided job id is complete: { 'JobStatus' : 'Complete' , 'CompletionPercentage' : 100 , 'TimeTakenToRenderInMs' : 25991 } Project . get_render_codecs ( render_format : str ) -> Dict [ Any , Any ] Returns all possible render codecs. Parameters: Name Type Description Default render_format str render format required Returns: Type Description Dict [ Any , Any ] Dict[Any, Any]: render codecs Project . set_render_format_and_codec ( format : str , codec : str ) -> bool Sets current format and codec Parameters: Name Type Description Default format str render format required codec str render codec required Returns: Name Type Description bool bool True if successful, False otherwise Project . available_resolutions ( format : Optional [ str ] = None , codec : Optional [ str ] = None ) -> List [ Dict [ Any , Any ]] Returns list of resolutions applicable for the given render format and render codec . Returns full list of resolutions if no argument is provided. Each element in the list is a dictionary with 2 keys \"Width\" and \"Height\". Parameters: Name Type Description Default format str render format None codec str render codec None Returns: Type Description List [ Dict [ Any , Any ]] List of available resolutions Project . is_rendering () -> bool Checks if DaVinci Resolve is rendering. Returns: Name Type Description bool bool True if rendering, False otherwise Project . load_render_preset ( preset_name : str ) -> bool Loads render preset preset_name . Parameters: Name Type Description Default preset_name str preset name required Returns: Name Type Description bool bool True if successful, False otherwise Project . save_render_preset_as ( preset_name : str ) -> bool Save current preset as preset_name . Parameters: Name Type Description Default preset_name str preset name required Returns: Name Type Description bool bool True if successful, False otherwise Project . set_render_settings ( render_settings : Dict [ Any , Any ]) -> bool Set render settings. Render Settings: render_settings = { \"SelectAllFrames\" : bool , # (when set True, the settings MarkIn and MarkOut are ignored) \"MarkIn\" : int , \"MarkOut\" : int , \"TargetDir\" : str , \"CustomName\" : str , \"UniqueFilenameStyle\" : int , # 0 - Prefix, 1 - Suffix. \"ExportVideo\" : bool , \"ExportAudio\" : bool , \"FormatWidth\" : int , \"FormatHeight\" : int , \"FrameRate\" : float , # (examples: 23.976, 24) \"PixelAspectRatio\" : str , # (for SD resolution: \"16_9\" or \"4_3\") (other resolutions: \"square\" or \"cinemascope\") \"VideoQuality\" : Union [ int , str ], # possible values for current codec (if applicable): # 0 (int) - will set quality to automatic # [1 -> MAX] (int) - will set input bit rate # [\"Least\", \"Low\", \"Medium\", \"High\", \"Best\"] (String) - will set input quality level \"AudioCodec\" : str , # (example: \"aac\") \"AudioBitDepth\" : int , \"AudioSampleRate\" : int , \"ColorSpaceTag\" : str , # (example: \"Same as Project\", \"AstroDesign\") \"GammaTag\" : str , # (example: \"Same as Project\", \"ACEScct\") \"ExportAlpha\" : bool , \"EncodingProfile\" : str , # (example: \"Main10\"). Can only be set for H.264 and H.265. \"MultiPassEncode\" : bool , # Can only be set for H.264. \"AlphaMode\" : int , # 0 - Premultiplied, 1 - Straight. Can only be set if \"ExportAlpha\" is true. \"NetworkOptimization\" : bool , # Only supported by QuickTime and MP4 formats. Parameters: Name Type Description Default render_settings dict dictionary with render settings required Returns: Name Type Description bool bool True if successful, False otherwise Project . get_setting ( settingname : Optional [ str ] = None ) -> Any Get project setting. If no setting provided, returns a dict with all settings. Parameters: Name Type Description Default setting str setting name required Returns: Name Type Description dict Any dict with setting name and value Project . set_setting ( setting : str , value : Any ) -> bool Set project setting. Parameters: Name Type Description Default setting str setting name required value Any setting value required Returns: Name Type Description bool bool True if successful, False otherwise Project . save () -> bool Saves project. Returns: Name Type Description bool bool True if successful, False otherwise Project . close () -> bool Closes current project. Returns: Name Type Description bool bool True if successful, False otherwise Project . open_timeline ( name : str ) -> bool Opens timeline named name . Parameters: Name Type Description Default name str timeline name required Returns: Name Type Description bool bool True if successful, False otherwise Project . refresh_luts () -> bool Refresh luts. Returns: Name Type Description None bool None","title":"Project"},{"location":"project/#pydavinci.wrappers.project.Project-attributes","text":"","title":"Attributes"},{"location":"project/#pydavinci.wrappers.project.Project.settings","text":"Returns the ProjectSettings interface.","title":"settings"},{"location":"project/#pydavinci.wrappers.project.Project.mediapool","text":"Returns the MediaPool object. Returns: Type Description MediaPool Media Storage object","title":"mediapool"},{"location":"project/#pydavinci.wrappers.project.Project.timeline_count","text":"Get total timeline count on current project Returns: Type Description int timeline count","title":"timeline_count"},{"location":"project/#pydavinci.wrappers.project.Project.name","text":"Gets or sets current project name Returns: Type Description str project name","title":"name"},{"location":"project/#pydavinci.wrappers.project.Project.presets","text":"Gets a list of available project presets Returns: Type Description List [ str ] project presets","title":"presets"},{"location":"project/#pydavinci.wrappers.project.Project.render_jobs","text":"Gets current list of render jobs Returns: Name Type Description list List [ str ] render job list","title":"render_jobs"},{"location":"project/#pydavinci.wrappers.project.Project.render_presets","text":"Gets available render presets list Returns: Name Type Description list List [ str ] available render presets list","title":"render_presets"},{"location":"project/#pydavinci.wrappers.project.Project.render_formats","text":"Gets all possible render formats. Returns: Name Type Description dict Dict [ Any , Any ] dict with render formats","title":"render_formats"},{"location":"project/#pydavinci.wrappers.project.Project.current_render_format_and_codec","text":"Gets current render format and codec. Returns: Name Type Description dict Dict [ Any , Any ] dict with current render format and codec","title":"current_render_format_and_codec"},{"location":"project/#pydavinci.wrappers.project.Project.render_mode","text":"Gets or sets current render mode. single for single clip and individual for individual clips. Returns: Type Description str render mode single or individual","title":"render_mode"},{"location":"project/#pydavinci.wrappers.project.Project.timeline","text":"Returns current Timeline object Returns: Name Type Description Timeline Timeline timeline object","title":"timeline"},{"location":"project/#pydavinci.wrappers.project.Project-functions","text":"","title":"Functions"},{"location":"project/#pydavinci.wrappers.project.Project.set_preset","text":"Activates preset_name Parameters: Name Type Description Default preset_name str preset name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"set_preset()"},{"location":"project/#pydavinci.wrappers.project.Project.add_renderjob","text":"Adds current render settings to a render job. If there are already rendered jobs in the render queue and you're executing a lot of commands, there's a bug on the Davinci API that there's a chance it will return an empty string instead of the job ID. block blocks the program until we get a job id back from Davinci Resolve. It's True by default. Returns: Name Type Description str str render job id","title":"add_renderjob()"},{"location":"project/#pydavinci.wrappers.project.Project.delete_renderjob","text":"Deletes render job job_id Parameters: Name Type Description Default job_id str render job id required Returns: Name Type Description bool bool True if successful, False otherwise","title":"delete_renderjob()"},{"location":"project/#pydavinci.wrappers.project.Project.delete_all_renderjobs","text":"Deletes all renderjobs Returns: Name Type Description bool bool True if successful, False otherwise","title":"delete_all_renderjobs()"},{"location":"project/#pydavinci.wrappers.project.Project.render","text":"Render jobs Parameters: Name Type Description Default job_ids Union [None, List [ str ]] Renders provided list of job ids . If None provided, render all jobs in queue. Defaults to None . None interactive bool Whether to use interactive mode. When set to True , enables error feedback in the UI during rendering. True Returns: Name Type Description bool bool True if successful, False otherwise","title":"render()"},{"location":"project/#pydavinci.wrappers.project.Project.stop_render","text":"Stops all rendering. Returns: Name Type Description None None None","title":"stop_render()"},{"location":"project/#pydavinci.wrappers.project.Project.render_status","text":"Gets render status on job_id Parameters: Name Type Description Default job_id str job id required Returns: Name Type Description dict Dict [ Any , Union [ str , int ]] dictionary with render status Render Status The dictionary returned looks like this when rendering: { 'JobStatus' : 'Rendering' , 'CompletionPercentage' : 92 , 'EstimatedTimeRemainingInMs' : 1000 } And like this when the render on the provided job id is complete: { 'JobStatus' : 'Complete' , 'CompletionPercentage' : 100 , 'TimeTakenToRenderInMs' : 25991 }","title":"render_status()"},{"location":"project/#pydavinci.wrappers.project.Project.get_render_codecs","text":"Returns all possible render codecs. Parameters: Name Type Description Default render_format str render format required Returns: Type Description Dict [ Any , Any ] Dict[Any, Any]: render codecs","title":"get_render_codecs()"},{"location":"project/#pydavinci.wrappers.project.Project.set_render_format_and_codec","text":"Sets current format and codec Parameters: Name Type Description Default format str render format required codec str render codec required Returns: Name Type Description bool bool True if successful, False otherwise","title":"set_render_format_and_codec()"},{"location":"project/#pydavinci.wrappers.project.Project.available_resolutions","text":"Returns list of resolutions applicable for the given render format and render codec . Returns full list of resolutions if no argument is provided. Each element in the list is a dictionary with 2 keys \"Width\" and \"Height\". Parameters: Name Type Description Default format str render format None codec str render codec None Returns: Type Description List [ Dict [ Any , Any ]] List of available resolutions","title":"available_resolutions()"},{"location":"project/#pydavinci.wrappers.project.Project.is_rendering","text":"Checks if DaVinci Resolve is rendering. Returns: Name Type Description bool bool True if rendering, False otherwise","title":"is_rendering()"},{"location":"project/#pydavinci.wrappers.project.Project.load_render_preset","text":"Loads render preset preset_name . Parameters: Name Type Description Default preset_name str preset name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"load_render_preset()"},{"location":"project/#pydavinci.wrappers.project.Project.save_render_preset_as","text":"Save current preset as preset_name . Parameters: Name Type Description Default preset_name str preset name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"save_render_preset_as()"},{"location":"project/#pydavinci.wrappers.project.Project.set_render_settings","text":"Set render settings. Render Settings: render_settings = { \"SelectAllFrames\" : bool , # (when set True, the settings MarkIn and MarkOut are ignored) \"MarkIn\" : int , \"MarkOut\" : int , \"TargetDir\" : str , \"CustomName\" : str , \"UniqueFilenameStyle\" : int , # 0 - Prefix, 1 - Suffix. \"ExportVideo\" : bool , \"ExportAudio\" : bool , \"FormatWidth\" : int , \"FormatHeight\" : int , \"FrameRate\" : float , # (examples: 23.976, 24) \"PixelAspectRatio\" : str , # (for SD resolution: \"16_9\" or \"4_3\") (other resolutions: \"square\" or \"cinemascope\") \"VideoQuality\" : Union [ int , str ], # possible values for current codec (if applicable): # 0 (int) - will set quality to automatic # [1 -> MAX] (int) - will set input bit rate # [\"Least\", \"Low\", \"Medium\", \"High\", \"Best\"] (String) - will set input quality level \"AudioCodec\" : str , # (example: \"aac\") \"AudioBitDepth\" : int , \"AudioSampleRate\" : int , \"ColorSpaceTag\" : str , # (example: \"Same as Project\", \"AstroDesign\") \"GammaTag\" : str , # (example: \"Same as Project\", \"ACEScct\") \"ExportAlpha\" : bool , \"EncodingProfile\" : str , # (example: \"Main10\"). Can only be set for H.264 and H.265. \"MultiPassEncode\" : bool , # Can only be set for H.264. \"AlphaMode\" : int , # 0 - Premultiplied, 1 - Straight. Can only be set if \"ExportAlpha\" is true. \"NetworkOptimization\" : bool , # Only supported by QuickTime and MP4 formats. Parameters: Name Type Description Default render_settings dict dictionary with render settings required Returns: Name Type Description bool bool True if successful, False otherwise","title":"set_render_settings()"},{"location":"project/#pydavinci.wrappers.project.Project.get_setting","text":"Get project setting. If no setting provided, returns a dict with all settings. Parameters: Name Type Description Default setting str setting name required Returns: Name Type Description dict Any dict with setting name and value","title":"get_setting()"},{"location":"project/#pydavinci.wrappers.project.Project.set_setting","text":"Set project setting. Parameters: Name Type Description Default setting str setting name required value Any setting value required Returns: Name Type Description bool bool True if successful, False otherwise","title":"set_setting()"},{"location":"project/#pydavinci.wrappers.project.Project.save","text":"Saves project. Returns: Name Type Description bool bool True if successful, False otherwise","title":"save()"},{"location":"project/#pydavinci.wrappers.project.Project.close","text":"Closes current project. Returns: Name Type Description bool bool True if successful, False otherwise","title":"close()"},{"location":"project/#pydavinci.wrappers.project.Project.open_timeline","text":"Opens timeline named name . Parameters: Name Type Description Default name str timeline name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"open_timeline()"},{"location":"project/#pydavinci.wrappers.project.Project.refresh_luts","text":"Refresh luts. Returns: Name Type Description None bool None","title":"refresh_luts()"},{"location":"projectmanager/","text":"Attributes ProjectManager . projects -> List [ str ] property Returns a list with project names in current project manager folder Returns: Type Description List [ str ] List[str]: list of project names ProjectManager . folders -> List [ str ] property Returns a list with project manager folder names Returns: Type Description List [ str ] List[str]: list of folder names ProjectManager . folder -> str property Returns current folder name Returns: Name Type Description str str folder name ProjectManager . db -> Dict [ str , str ] property writable Gets or sets current database. For setting a Disk DB ProjectManager . db = { 'DbType' : 'Disk' , 'DbName' : 'Local Database' } For setting a PostgresSQL db ProjectManager . db = { 'DbType' : 'PostgreSQL' , 'DbName' : 'PostgresDB' , 'IpAddress' : '127.0.0.1' } Parameters: Name Type Description Default db_info dict valid db_info dict. required Returns: Name Type Description bool Dict [ str , str ] True if successful, False otherwise ProjectManager . db_list -> List [ Dict [ str , str ]] property Returns list of all databases Returns: Type Description List [ Dict [ str , str ]] list of databases Functions ProjectManager . create_project ( project_name : str ) -> Project Creates a project with project_name Parameters: Name Type Description Default project_name str project name required Returns: Name Type Description Project Project Project ProjectManager . delete_project ( project_name : str ) -> bool Deletes project project_name Parameters: Name Type Description Default project_name str project name required Returns: Name Type Description bool bool True if successful, False otherwise ProjectManager . load_project ( project_name : str ) -> Project Loads project project_name Parameters: Name Type Description Default project_name str project name required Returns: Name Type Description bool Project True if successful, False otherwise ProjectManager . close_project ( project_name : Project ) -> bool Closes project project_name Parameters: Name Type Description Default project_name str project name required Returns: Name Type Description bool bool True if successful, False otherwise ProjectManager . create_folder ( folder_name : str ) -> bool Creates project manager folder folder_name Parameters: Name Type Description Default folder_name str folder name required Returns: Name Type Description bool bool True if successful, False otherwise ProjectManager . delete_folder ( folder_name : str ) -> bool Deletes project manager folder folder_name Parameters: Name Type Description Default folder_name str folder name required Returns: Name Type Description bool bool True if successful, False otherwise ProjectManager . goto_root_folder () -> bool Goes to root project manager folder Returns: Name Type Description bool bool True if successful, False otherwise ProjectManager . goto_parent_folder () -> bool Goes to parent of current project manager folder Returns: Name Type Description bool bool True if successful, False otherwise ProjectManager . open_folder ( folder_name : str ) -> bool Open folder named folder_name Parameters: Name Type Description Default folder_name str folder name required Returns: Name Type Description bool bool True if successful, False otherwise ProjectManager . import_project ( path : str ) -> bool Imports .drp project located at path Parameters: Name Type Description Default path str path to .drp project required Returns: Name Type Description bool bool True if successful, False otherwise ProjectManager . export_project ( project_name : str , path : str , stills_and_luts : bool = False ) -> bool Exports project Parameters: Name Type Description Default project_name str project to be exported required path str path to export to required stills_and_luts bool whether to export with Stills and LUTs. Defaults to False. False Returns: Name Type Description bool bool True if successful, False otherwise ProjectManager . restore_project ( path : str ) -> bool Restore project from path Parameters: Name Type Description Default path str project path required Returns: Name Type Description bool bool True if successful, False otherwise","title":"ProjectManager"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager-attributes","text":"","title":"Attributes"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.projects","text":"Returns a list with project names in current project manager folder Returns: Type Description List [ str ] List[str]: list of project names","title":"projects"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.folders","text":"Returns a list with project manager folder names Returns: Type Description List [ str ] List[str]: list of folder names","title":"folders"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.folder","text":"Returns current folder name Returns: Name Type Description str str folder name","title":"folder"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.db","text":"Gets or sets current database. For setting a Disk DB ProjectManager . db = { 'DbType' : 'Disk' , 'DbName' : 'Local Database' } For setting a PostgresSQL db ProjectManager . db = { 'DbType' : 'PostgreSQL' , 'DbName' : 'PostgresDB' , 'IpAddress' : '127.0.0.1' } Parameters: Name Type Description Default db_info dict valid db_info dict. required Returns: Name Type Description bool Dict [ str , str ] True if successful, False otherwise","title":"db"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.db_list","text":"Returns list of all databases Returns: Type Description List [ Dict [ str , str ]] list of databases","title":"db_list"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager-functions","text":"","title":"Functions"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.create_project","text":"Creates a project with project_name Parameters: Name Type Description Default project_name str project name required Returns: Name Type Description Project Project Project","title":"create_project()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.delete_project","text":"Deletes project project_name Parameters: Name Type Description Default project_name str project name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"delete_project()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.load_project","text":"Loads project project_name Parameters: Name Type Description Default project_name str project name required Returns: Name Type Description bool Project True if successful, False otherwise","title":"load_project()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.close_project","text":"Closes project project_name Parameters: Name Type Description Default project_name str project name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"close_project()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.create_folder","text":"Creates project manager folder folder_name Parameters: Name Type Description Default folder_name str folder name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"create_folder()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.delete_folder","text":"Deletes project manager folder folder_name Parameters: Name Type Description Default folder_name str folder name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"delete_folder()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.goto_root_folder","text":"Goes to root project manager folder Returns: Name Type Description bool bool True if successful, False otherwise","title":"goto_root_folder()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.goto_parent_folder","text":"Goes to parent of current project manager folder Returns: Name Type Description bool bool True if successful, False otherwise","title":"goto_parent_folder()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.open_folder","text":"Open folder named folder_name Parameters: Name Type Description Default folder_name str folder name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"open_folder()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.import_project","text":"Imports .drp project located at path Parameters: Name Type Description Default path str path to .drp project required Returns: Name Type Description bool bool True if successful, False otherwise","title":"import_project()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.export_project","text":"Exports project Parameters: Name Type Description Default project_name str project to be exported required path str path to export to required stills_and_luts bool whether to export with Stills and LUTs. Defaults to False. False Returns: Name Type Description bool bool True if successful, False otherwise","title":"export_project()"},{"location":"projectmanager/#pydavinci.wrappers.projectmanager.ProjectManager.restore_project","text":"Restore project from path Parameters: Name Type Description Default path str project path required Returns: Name Type Description bool bool True if successful, False otherwise","title":"restore_project()"},{"location":"resolve/","text":"Attributes Resolve . pages = [ 'media' , 'cut' , 'edit' , 'fusion' , 'color' , 'fairlight' , 'deliver' ] instance-attribute Available pages to switch to using Resolve.page Resolve . project_manager -> 'ProjectManager' property Returns the ProjectManager object. Returns: Type Description ProjectManager Project Manager object Resolve . media_storage -> 'MediaStorage' property Returns the MediaStorage object. Returns: Type Description MediaStorage Media Storage object Resolve . media_pool -> 'MediaPool' property Returns the MediaPool object. Returns: Type Description MediaPool Media Storage object Resolve . project -> 'Project' property Returns the current active Project object. Returns: Type Description Project Project object Resolve . active_timeline -> 'Timeline' property Returns the current active Timeline object. Returns: Type Description Timeline Timeline object Resolve . page -> str property writable Gets or sets current Resolve Page . Note that certain methods are only available when in the right page. Parameters: Name Type Description Default page str valid page required Returns: Name Type Description None str None Resolve . product_name -> str property Returns: Name Type Description str str product name Resolve . version -> str property Returns: Name Type Description str str version Resolve . fusion -> Any property Returns the Fusion object. Fusion Object This is object is the same as the regular Fusion API. You can call fusion.__dir__() to see all available methods. See The last Fusion API documentation for more details. Returns: Type Description Fusion Fusion object Functions Resolve . load_layout ( layout_name : str ) -> bool Loads saved layout named layout_name Parameters: Name Type Description Default layout_name str layout name required Returns: Name Type Description bool bool True if successful, False otherwise Resolve . update_layout ( layout_name : str ) -> bool Updates current layout to layout_name Parameters: Name Type Description Default layout_name str layout to be updated required Returns: Name Type Description bool bool True if successful, False otherwise Resolve . save_layout ( layout_name : str ) -> bool Saves current layout as layout_name Parameters: Name Type Description Default layout_name str layout name required Returns: Name Type Description bool bool True if successful, False otherwise Resolve . import_layout ( path : str , layout_name : str ) -> bool Import layout_name from path Parameters: Name Type Description Default path str path to layout file required layout_name str name to be imported as required Returns: Name Type Description bool bool True if successful, False otherwise Resolve . quit () -> None Quits Davinci Resolve Returns: Name Type Description None None None","title":"Resolve"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve-attributes","text":"","title":"Attributes"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.pages","text":"Available pages to switch to using Resolve.page","title":"pages"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.project_manager","text":"Returns the ProjectManager object. Returns: Type Description ProjectManager Project Manager object","title":"project_manager"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.media_storage","text":"Returns the MediaStorage object. Returns: Type Description MediaStorage Media Storage object","title":"media_storage"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.media_pool","text":"Returns the MediaPool object. Returns: Type Description MediaPool Media Storage object","title":"media_pool"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.project","text":"Returns the current active Project object. Returns: Type Description Project Project object","title":"project"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.active_timeline","text":"Returns the current active Timeline object. Returns: Type Description Timeline Timeline object","title":"active_timeline"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.page","text":"Gets or sets current Resolve Page . Note that certain methods are only available when in the right page. Parameters: Name Type Description Default page str valid page required Returns: Name Type Description None str None","title":"page"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.product_name","text":"Returns: Name Type Description str str product name","title":"product_name"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.version","text":"Returns: Name Type Description str str version","title":"version"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.fusion","text":"Returns the Fusion object. Fusion Object This is object is the same as the regular Fusion API. You can call fusion.__dir__() to see all available methods. See The last Fusion API documentation for more details. Returns: Type Description Fusion Fusion object","title":"fusion"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve-functions","text":"","title":"Functions"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.load_layout","text":"Loads saved layout named layout_name Parameters: Name Type Description Default layout_name str layout name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"load_layout()"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.update_layout","text":"Updates current layout to layout_name Parameters: Name Type Description Default layout_name str layout to be updated required Returns: Name Type Description bool bool True if successful, False otherwise","title":"update_layout()"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.save_layout","text":"Saves current layout as layout_name Parameters: Name Type Description Default layout_name str layout name required Returns: Name Type Description bool bool True if successful, False otherwise","title":"save_layout()"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.import_layout","text":"Import layout_name from path Parameters: Name Type Description Default path str path to layout file required layout_name str name to be imported as required Returns: Name Type Description bool bool True if successful, False otherwise","title":"import_layout()"},{"location":"resolve/#pydavinci.wrappers.resolve.Resolve.quit","text":"Quits Davinci Resolve Returns: Name Type Description None None None","title":"quit()"},{"location":"timeline/","text":"Timeline . markers property Returns the Marker Collection for this Timeline . Attributes Timeline . settings -> 'TimelineSettings' property Returns the TimelineSettings interface. Timeline.custom_settings(True) must be called first. Timeline . name -> str property writable Gets or sets timeline name Parameters: Name Type Description Default name str new timeline name required Returns: Name Type Description bool str True if successful, False otherwise Timeline . start_frame -> int property Gets timeline start frame Returns: Name Type Description int int start frame Timeline . end_frame -> int property Gets timeline end frame Returns: Name Type Description int int end frame Timeline . timecode -> str property Gets current timecode Returns: Name Type Description str str timecode Timeline . current_video_item -> 'TimelineItem' property Returns current video TimelineItem Returns: Name Type Description TimelineItem 'TimelineItem' current TimelineItem Timeline . current_clip_thumbnail -> Dict [ Any , Any ] property Returns a dict with data containing metadata + raw thumbnail image data (RGB 8-bit image data encoded in base64 format) for current media in the Color Page. Returns: Name Type Description dict Dict [ Any , Any ] (keys \"width\", \"height\", \"format\" and \"data\") Functions Timeline . custom_settings ( use : bool ) -> bool Allows this timeline to have settings independent from the project settings. See Quickstart on Settings for more details. Parameters: Name Type Description Default use bool True to use independent settings, False to follow project settings. required Timeline . activate () -> bool Makes this timeline active Returns: Name Type Description bool bool True if successful, False otherwise Timeline . track_count ( track_type : str ) -> int Gets track count on track_type Parameters: Name Type Description Default track_type str valid track_types : video , audio , subtitle required Raises: Type Description ValueError Not a valid track type Returns: Name Type Description int int number of tracks Timeline . items ( track_type : str , track_index : int ) -> List [ 'TimelineItem' ] Gets TimelineItem s from a track Parameters: Name Type Description Default track_type str valid track_type : video , audio , subtitle required track_index int track index. Starts at 1 required Raises: Type Description ValueError Not a valid track type Returns: Type Description List [ TimelineItem ] list of items at specified track Timeline . apply_grade_from_DRX ( drx_path : str , grade_mode : int , timeline_items : List [ 'TimelineItem' ]) -> bool Applies drx grade on a list of TimelineItem s Parameters: Name Type Description Default drx_path str path to a .drx file required grade_mode int grade mode to use. 0 for No Keyframes , 1 for Source Timecode aligned and 2 for Start Frames aligned . required timeline_items List [ TimelineItem ] timeline items to apply grade to required Returns: Name Type Description bool bool True if successful, False otherwise Timeline . get_track_name ( track_type : str , track_index : int ) -> str Gets track name Parameters: Name Type Description Default track_type str valid track_type: video , audio or subtitle required track_index int track index. Starts at 1 required Raises: Type Description ValueError Not a valid track type Returns: Name Type Description str str track name Timeline . set_track_name ( track_type : str , track_index : int , new_name : str ) -> bool Sets track name Parameters: Name Type Description Default track_type str valid track_type: video , audio or subtitle required track_index int track index. Starts at 1 required new_name str new name required Raises: Type Description ValueError Not a valid track type Returns: Type Description bool True if successful, False otherwise Timeline . duplicate_timeline ( timeline_name : Optional [ str ] = None ) -> 'Timeline' Duplicates this timeline Parameters: Name Type Description Default timeline_name str New timeline name. If not provided, appends \"Copy\" to timeline name. None Returns: Type Description Timeline new duplicated timeline Timeline . create_compound_clip ( timeline_items : List [ 'TimelineItem' ], clip_info : Optional [ Dict [ Any , Any ]] = None ) -> 'TimelineItem' Creates a compound clip using timeline_items Parameters: Name Type Description Default timeline_items List [ TimelineItem ] list of TimelineItem s to use required clip_info dict optional compound clip settings. Valid dict: { \"startTimecode\" : \"00:00:00:00\" , \"name\" : \"Compound Clip 1\" } None Returns: Type Description TimelineItem compound clip Timeline . create_fusion_clip ( timeline_items : List [ 'TimelineItem' ]) -> 'TimelineItem' Creates a Fusion clip with timeline_items Parameters: Name Type Description Default timeline_items List [ TimelineItem ] timeline items to be used as input in the Fusion clip required Returns: Type Description TimelineItem resulting fusion clip Timeline . import_aaf_into_timeline ( file_path : str , import_options : Optional [ Dict [ Any , Any ]] = None ) -> bool Imports an aaf into the timeline Import Options Imports timeline items from an AAF file and optional import_options dict into the timeline, with support for the keys: \"autoImportSourceClipsIntoMediaPool\" : bool , specifies if source clips should be imported into media pool, True by default \"ignoreFileExtensionsWhenMatching\" : bool , specifies if file extensions should be ignored when matching, False by default \"linkToSourceCameraFiles\" : bool, specifies if link to source camera files should be enabled, False by default \"useSizingInfo\" : bool , specifies if sizing information should be used, False by default \"importMultiChannelAudioTracksAsLinkedGroups\" : bool, specifies if multi-channel audio tracks should be imported as linked groups, False by default \"insertAdditionalTracks\" : bool, specifies if additional tracks should be inserted, True by default \"insertWithOffset\" : str , specifies insert with offset value in timecode format - defaults to \"00:00:00:00\" , applicable if \"insertAdditionalTracks\" is False \"sourceClipsPath\" : str , specifies a filesystem path to search for source clips if the media is inaccessible in their original path and if \"ignoreFileExtensionsWhenMatching\" is True \"sourceClipsFolders\" : str , list of Folder objects to search for source clips if the media is not present in current folder Parameters: Name Type Description Default file_path str path to .aaf file required import_options dict optional import options. See description above. Defaults to {}. None Returns: Name Type Description bool bool True if successful, False otherwise Timeline . export ( file_name : str , export_type : str , export_subtype : Optional [ str ] = None ) -> bool Exports timeline file (.aaf, .xml, etc) Supported export_type : \"AAF\" \"DRT\" \"EDL\" \"FCP_7_XML\" \"FCPXML_1_3\" \"FCPXML_1_4\" \"FCPXML_1_5\" \"FCPXML_1_6\" \"FCPXML_1_7\" \"FCPXML_1_8\" \"HDR_10_PROFILE_A\" \"HDR_10_PROFILE_B\" \"TEXT_CSV\" \"TEXT_TAB\" \"DOLBY_VISION_VER_2_9\" \"DOLBY_VISION_VER_4_0\" Supported export_subtype : \"NONE\" \"AAF_NEW\" \"AAF_EXISTING\" \"CDL\" \"SDL\" \"MISSING_CLIPS\" Export types and subtypes Please note that export_subtype is a required parameter for AAF and EDL . For rest of the export_type , export_subtype is ignored. When export_type is AAF , valid export_subtype values are AAF_NEW and AAF_EXISTING . When export_type is EXPORT_EDL , valid export_dubtype values are EXPORT_CDL , EXPORT_SDL , EXPORT_MISSING_CLIPS and EXPORT_NONE . Parameters: Name Type Description Default file_name str full filepath to export to including file name required export_type _type_ supported export type required export_subtype _type_ supported export subtype None Returns: Name Type Description bool bool True if successful, False otherwise Timeline . get_setting ( settingname : Optional [ str ] = None ) -> Union [ str , int , float , Dict [ Any , Any ]] This function is a fallback if using Timeline.settings doesn't work. Get timeline setting. If no setting provided, returns a dict with all settings. Parameters: Name Type Description Default settingname str setting name. None Returns: Type Description Union [ str , int , float , Dict [ Any , Any ]] Union[str, Dict]: setting(s) Timeline . set_setting ( setting_name : str , value : Union [ str , int , float , Dict [ Any , Any ]]) -> bool This function is a fallback if using Timeline.settings doesn't work. Sets Timeline setting seting_name to value Parameters: Name Type Description Default setting_name str setting name required value Union[str, int, Dict[Any, Any] setting value required Returns: Type Description bool True if successful, False otherwise Timeline . insert_generator ( generator_name : str ) -> 'TimelineItem' Inserts a generator in the timeline Parameters: Name Type Description Default generator_name str generator name to be inserted required Returns: Type Description TimelineItem generator Timeline . insert_fusion_generator ( generator_name : str ) -> 'TimelineItem' Inserts a fusion generator in the timeline Parameters: Name Type Description Default generator_name str fusion generator name required Returns: Type Description TimelineItem fusion generator Timeline . insert_ofx_generator ( generator_name : str ) -> 'TimelineItem' Inserts an OFX generator in the timeline Parameters: Name Type Description Default generator_name str OFX generator name required Returns: Type Description TimelineItem OFX generator Timeline . insert_title ( title_name : str ) -> 'TimelineItem' Inserts a title in the timeline Parameters: Name Type Description Default title_name str title name required Returns: Type Description TimelineItem title Timeline . insert_fusion_title ( title_name : str ) -> 'TimelineItem' Inserts a fusion title in the timeline Parameters: Name Type Description Default title_name str fusion title name required Returns: Type Description TimelineItem fusion title","title":"Timeline"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline-attributes","text":"","title":"Attributes"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.settings","text":"Returns the TimelineSettings interface. Timeline.custom_settings(True) must be called first.","title":"settings"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.name","text":"Gets or sets timeline name Parameters: Name Type Description Default name str new timeline name required Returns: Name Type Description bool str True if successful, False otherwise","title":"name"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.start_frame","text":"Gets timeline start frame Returns: Name Type Description int int start frame","title":"start_frame"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.end_frame","text":"Gets timeline end frame Returns: Name Type Description int int end frame","title":"end_frame"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.timecode","text":"Gets current timecode Returns: Name Type Description str str timecode","title":"timecode"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.current_video_item","text":"Returns current video TimelineItem Returns: Name Type Description TimelineItem 'TimelineItem' current TimelineItem","title":"current_video_item"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.current_clip_thumbnail","text":"Returns a dict with data containing metadata + raw thumbnail image data (RGB 8-bit image data encoded in base64 format) for current media in the Color Page. Returns: Name Type Description dict Dict [ Any , Any ] (keys \"width\", \"height\", \"format\" and \"data\")","title":"current_clip_thumbnail"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline-functions","text":"","title":"Functions"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.custom_settings","text":"Allows this timeline to have settings independent from the project settings. See Quickstart on Settings for more details. Parameters: Name Type Description Default use bool True to use independent settings, False to follow project settings. required","title":"custom_settings()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.activate","text":"Makes this timeline active Returns: Name Type Description bool bool True if successful, False otherwise","title":"activate()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.track_count","text":"Gets track count on track_type Parameters: Name Type Description Default track_type str valid track_types : video , audio , subtitle required Raises: Type Description ValueError Not a valid track type Returns: Name Type Description int int number of tracks","title":"track_count()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.items","text":"Gets TimelineItem s from a track Parameters: Name Type Description Default track_type str valid track_type : video , audio , subtitle required track_index int track index. Starts at 1 required Raises: Type Description ValueError Not a valid track type Returns: Type Description List [ TimelineItem ] list of items at specified track","title":"items()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.apply_grade_from_DRX","text":"Applies drx grade on a list of TimelineItem s Parameters: Name Type Description Default drx_path str path to a .drx file required grade_mode int grade mode to use. 0 for No Keyframes , 1 for Source Timecode aligned and 2 for Start Frames aligned . required timeline_items List [ TimelineItem ] timeline items to apply grade to required Returns: Name Type Description bool bool True if successful, False otherwise","title":"apply_grade_from_DRX()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.get_track_name","text":"Gets track name Parameters: Name Type Description Default track_type str valid track_type: video , audio or subtitle required track_index int track index. Starts at 1 required Raises: Type Description ValueError Not a valid track type Returns: Name Type Description str str track name","title":"get_track_name()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.set_track_name","text":"Sets track name Parameters: Name Type Description Default track_type str valid track_type: video , audio or subtitle required track_index int track index. Starts at 1 required new_name str new name required Raises: Type Description ValueError Not a valid track type Returns: Type Description bool True if successful, False otherwise","title":"set_track_name()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.duplicate_timeline","text":"Duplicates this timeline Parameters: Name Type Description Default timeline_name str New timeline name. If not provided, appends \"Copy\" to timeline name. None Returns: Type Description Timeline new duplicated timeline","title":"duplicate_timeline()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.create_compound_clip","text":"Creates a compound clip using timeline_items Parameters: Name Type Description Default timeline_items List [ TimelineItem ] list of TimelineItem s to use required clip_info dict optional compound clip settings. Valid dict: { \"startTimecode\" : \"00:00:00:00\" , \"name\" : \"Compound Clip 1\" } None Returns: Type Description TimelineItem compound clip","title":"create_compound_clip()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.create_fusion_clip","text":"Creates a Fusion clip with timeline_items Parameters: Name Type Description Default timeline_items List [ TimelineItem ] timeline items to be used as input in the Fusion clip required Returns: Type Description TimelineItem resulting fusion clip","title":"create_fusion_clip()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.import_aaf_into_timeline","text":"Imports an aaf into the timeline Import Options Imports timeline items from an AAF file and optional import_options dict into the timeline, with support for the keys: \"autoImportSourceClipsIntoMediaPool\" : bool , specifies if source clips should be imported into media pool, True by default \"ignoreFileExtensionsWhenMatching\" : bool , specifies if file extensions should be ignored when matching, False by default \"linkToSourceCameraFiles\" : bool, specifies if link to source camera files should be enabled, False by default \"useSizingInfo\" : bool , specifies if sizing information should be used, False by default \"importMultiChannelAudioTracksAsLinkedGroups\" : bool, specifies if multi-channel audio tracks should be imported as linked groups, False by default \"insertAdditionalTracks\" : bool, specifies if additional tracks should be inserted, True by default \"insertWithOffset\" : str , specifies insert with offset value in timecode format - defaults to \"00:00:00:00\" , applicable if \"insertAdditionalTracks\" is False \"sourceClipsPath\" : str , specifies a filesystem path to search for source clips if the media is inaccessible in their original path and if \"ignoreFileExtensionsWhenMatching\" is True \"sourceClipsFolders\" : str , list of Folder objects to search for source clips if the media is not present in current folder Parameters: Name Type Description Default file_path str path to .aaf file required import_options dict optional import options. See description above. Defaults to {}. None Returns: Name Type Description bool bool True if successful, False otherwise","title":"import_aaf_into_timeline()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.export","text":"Exports timeline file (.aaf, .xml, etc) Supported export_type : \"AAF\" \"DRT\" \"EDL\" \"FCP_7_XML\" \"FCPXML_1_3\" \"FCPXML_1_4\" \"FCPXML_1_5\" \"FCPXML_1_6\" \"FCPXML_1_7\" \"FCPXML_1_8\" \"HDR_10_PROFILE_A\" \"HDR_10_PROFILE_B\" \"TEXT_CSV\" \"TEXT_TAB\" \"DOLBY_VISION_VER_2_9\" \"DOLBY_VISION_VER_4_0\" Supported export_subtype : \"NONE\" \"AAF_NEW\" \"AAF_EXISTING\" \"CDL\" \"SDL\" \"MISSING_CLIPS\" Export types and subtypes Please note that export_subtype is a required parameter for AAF and EDL . For rest of the export_type , export_subtype is ignored. When export_type is AAF , valid export_subtype values are AAF_NEW and AAF_EXISTING . When export_type is EXPORT_EDL , valid export_dubtype values are EXPORT_CDL , EXPORT_SDL , EXPORT_MISSING_CLIPS and EXPORT_NONE . Parameters: Name Type Description Default file_name str full filepath to export to including file name required export_type _type_ supported export type required export_subtype _type_ supported export subtype None Returns: Name Type Description bool bool True if successful, False otherwise","title":"export()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.get_setting","text":"This function is a fallback if using Timeline.settings doesn't work. Get timeline setting. If no setting provided, returns a dict with all settings. Parameters: Name Type Description Default settingname str setting name. None Returns: Type Description Union [ str , int , float , Dict [ Any , Any ]] Union[str, Dict]: setting(s)","title":"get_setting()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.set_setting","text":"This function is a fallback if using Timeline.settings doesn't work. Sets Timeline setting seting_name to value Parameters: Name Type Description Default setting_name str setting name required value Union[str, int, Dict[Any, Any] setting value required Returns: Type Description bool True if successful, False otherwise","title":"set_setting()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.insert_generator","text":"Inserts a generator in the timeline Parameters: Name Type Description Default generator_name str generator name to be inserted required Returns: Type Description TimelineItem generator","title":"insert_generator()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.insert_fusion_generator","text":"Inserts a fusion generator in the timeline Parameters: Name Type Description Default generator_name str fusion generator name required Returns: Type Description TimelineItem fusion generator","title":"insert_fusion_generator()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.insert_ofx_generator","text":"Inserts an OFX generator in the timeline Parameters: Name Type Description Default generator_name str OFX generator name required Returns: Type Description TimelineItem OFX generator","title":"insert_ofx_generator()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.insert_title","text":"Inserts a title in the timeline Parameters: Name Type Description Default title_name str title name required Returns: Type Description TimelineItem title","title":"insert_title()"},{"location":"timeline/#pydavinci.wrappers.timeline.Timeline.insert_fusion_title","text":"Inserts a fusion title in the timeline Parameters: Name Type Description Default title_name str fusion title name required Returns: Type Description TimelineItem fusion title","title":"insert_fusion_title()"},{"location":"timelineitem/","text":"TimelineItem . markers property Returns the Marker Collection for this TimelineItem . Attributes TimelineItem . name -> str property Gets name of TimelineItem Returns: Name Type Description str str name TimelineItem . duration -> int property Get duration in frames Returns: Name Type Description int int duration in frames TimelineItem . start -> int property Returns the start frame position on the timeline. Returns: Name Type Description int int start frame position TimelineItem . end -> int property Returns the start frame position on the timeline. Returns: Name Type Description int int end frame position TimelineItem . left_offset -> int property Returns the maximum extension by frame for clip from left side. Returns: Name Type Description int int left offset frame count TimelineItem . right_offset -> int property Returns the maximum extension by frame for clip from right side. Returns: Name Type Description int int right offset frame count TimelineItem . properties -> Dict [ Any , Any ] property Gets all clip properties Returns: Name Type Description dict Dict [ Any , Any ] dict with clip properties TimelineItem . flags -> List [ str ] property Gets flag list Returns: Type Description List [ str ] List[str]: list of flags TimelineItem . color -> str property writable Gets or sets clip color Parameters: Name Type Description Default color str color to be applied required Returns: Name Type Description bool str True if successful, False otherwise TimelineItem . mediapoolitem -> 'MediaPoolItem' property Returns the corresponding MediaPoolItem for this TimelineItem Returns: Name Type Description MediaPoolItem 'MediaPoolItem' MediaPoolItem TimelineItem . take -> int property writable Gets or sets current take Parameters: Name Type Description Default takeindex int take index for selection required TimelineItem . takes -> int property Get total number of takes Returns: Name Type Description int int total number of takes Functions TimelineItem . set_property ( key : str , value : Union [ str , int , float ]) -> bool Sets property Parameters: Name Type Description Default name str property name required value Union [ str , int , float ] property value required Returns: Name Type Description bool bool True if successful, False otherwise TimelineItem . add_flag ( color : str ) -> bool Adds flag Parameters: Name Type Description Default color str valid flag required Returns: Name Type Description bool bool True if successful, False otherwise TimelineItem . clear_flags ( color : str = 'All' ) -> bool Clears all flags Parameters: Name Type Description Default color str clears flags by color . If All provided, clear all flags. Defaults to \"All\". 'All' Returns: Name Type Description bool bool description TimelineItem . clear_color () -> bool Clears clip color Returns: Name Type Description bool bool True if successful, False otherwise TimelineItem . add_color_version ( name : str , type : Literal [ 'local' , 'remote' ]) -> bool Adds color version to this TimelineItem Parameters: Name Type Description Default name str version name required type Literal ['local', 'remote'] whether to add a local or remote color version required Returns: Name Type Description bool bool True if successful, False otherwise TimelineItem . delete_color_version ( name : str , type : Literal [ 'local' , 'remote' ]) -> bool Adds color version from this TimelineItem Parameters: Name Type Description Default name str version name required type Literal ['local', 'remote'] whether to delete a local or remote color version required Returns: Name Type Description bool bool True if successful, False otherwise TimelineItem . load_color_version ( name : str , type : Literal [ 'local' , 'remote' ]) -> bool Loads color version from TimelineItem named name Parameters: Name Type Description Default name str version name required type Literal ['local', 'remote'] whether to load a local or remote color version required Returns: Name Type Description bool bool True if successful, False otherwise TimelineItem . rename_version ( oldname : str , newname : str , type : Literal [ 'local' , 'remote' ]) -> bool Renames a color version named oldname to newname on this TimelineItem Parameters: Name Type Description Default oldname str current version name required newname str new version name required type Literal ['local', 'remote'] whether to rename a local or remote color version required Returns: Name Type Description bool bool True if successful, False otherwise TimelineItem . set_lut ( node_index : int , lut_path : str ) -> bool Sets lut located on lut_path at node_index Parameters: Name Type Description Default node_index int node index required lut_path str lut path required Returns: Name Type Description bool bool True if successful, False otherwise TimelineItem . set_cdl ( cdl : Dict [ Any , Any ]) -> bool Sets CDL Parameters: Name Type Description Default cdl dict valid CDL dict required Example myclip . set_cdl ({ \"NodeIndex\" : \"1\" , \"Slope\" : \"0.5 0.4 0.2\" , \"Offset\" : \"0.4 0.3 0.2\" , \"Power\" : \"0.6 0.7 0.8\" , \"Saturation\" : \"0.65\" }) Returns: Name Type Description bool bool True if successful, False otherwise TimelineItem . add_take ( mediapool_item : 'MediaPoolItem' , startframe : int = 0 , endframe : int = 0 ) -> bool Adds mediapool_item as a new take. Initializes a take selector for the timeline item if needed. By default, the full clip extents is added. startframe and endFrame are optional arguments used to specify the extents. Parameters: Name Type Description Default mediapool_item MediaPoolItem media pool item to add as take required startframe int start frame for new take. Defaults to 0. 0 endframe int end frame for new take. Defaults to 0. 0 Returns: Name Type Description bool bool description TimelineItem . take_info ( takeindex : int = 0 ) -> Dict [ Any , Any ] Gets take info. If no takeindex provided, uses current selected take. Parameters: Name Type Description Default takeindex int take index to get info from. Defaults to current take. 0 Returns: Name Type Description dict Dict [ Any , Any ] description TimelineItem . delete_take ( takeindex : int ) -> bool Deletes take index with index takeindex Parameters: Name Type Description Default takeindex int take index to be deleted required Returns: Name Type Description bool bool True if successful, False otherwise TimelineItem . finalize_take ( takeindex : int = 0 ) -> bool Finalizes take at takeindex . If no takeindex provided, finalizes current take. Parameters: Name Type Description Default takeindex int take index to be finalized. Defaults to current take. 0 Returns: Name Type Description bool bool description TimelineItem . copy_grade_to ( timeline_items : List [ 'TimelineItem' ]) -> bool Copies the current grade to all the items in timneline_items list Parameters: Name Type Description Default timeline_items list list with clips for the grade to be applied required Returns: Name Type Description bool bool True if successful, False otherwise","title":"TimelineItem"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem-attributes","text":"","title":"Attributes"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.name","text":"Gets name of TimelineItem Returns: Name Type Description str str name","title":"name"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.duration","text":"Get duration in frames Returns: Name Type Description int int duration in frames","title":"duration"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.start","text":"Returns the start frame position on the timeline. Returns: Name Type Description int int start frame position","title":"start"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.end","text":"Returns the start frame position on the timeline. Returns: Name Type Description int int end frame position","title":"end"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.left_offset","text":"Returns the maximum extension by frame for clip from left side. Returns: Name Type Description int int left offset frame count","title":"left_offset"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.right_offset","text":"Returns the maximum extension by frame for clip from right side. Returns: Name Type Description int int right offset frame count","title":"right_offset"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.properties","text":"Gets all clip properties Returns: Name Type Description dict Dict [ Any , Any ] dict with clip properties","title":"properties"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.flags","text":"Gets flag list Returns: Type Description List [ str ] List[str]: list of flags","title":"flags"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.color","text":"Gets or sets clip color Parameters: Name Type Description Default color str color to be applied required Returns: Name Type Description bool str True if successful, False otherwise","title":"color"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.mediapoolitem","text":"Returns the corresponding MediaPoolItem for this TimelineItem Returns: Name Type Description MediaPoolItem 'MediaPoolItem' MediaPoolItem","title":"mediapoolitem"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.take","text":"Gets or sets current take Parameters: Name Type Description Default takeindex int take index for selection required","title":"take"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.takes","text":"Get total number of takes Returns: Name Type Description int int total number of takes","title":"takes"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem-functions","text":"","title":"Functions"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.set_property","text":"Sets property Parameters: Name Type Description Default name str property name required value Union [ str , int , float ] property value required Returns: Name Type Description bool bool True if successful, False otherwise","title":"set_property()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.add_flag","text":"Adds flag Parameters: Name Type Description Default color str valid flag required Returns: Name Type Description bool bool True if successful, False otherwise","title":"add_flag()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.clear_flags","text":"Clears all flags Parameters: Name Type Description Default color str clears flags by color . If All provided, clear all flags. Defaults to \"All\". 'All' Returns: Name Type Description bool bool description","title":"clear_flags()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.clear_color","text":"Clears clip color Returns: Name Type Description bool bool True if successful, False otherwise","title":"clear_color()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.add_color_version","text":"Adds color version to this TimelineItem Parameters: Name Type Description Default name str version name required type Literal ['local', 'remote'] whether to add a local or remote color version required Returns: Name Type Description bool bool True if successful, False otherwise","title":"add_color_version()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.delete_color_version","text":"Adds color version from this TimelineItem Parameters: Name Type Description Default name str version name required type Literal ['local', 'remote'] whether to delete a local or remote color version required Returns: Name Type Description bool bool True if successful, False otherwise","title":"delete_color_version()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.load_color_version","text":"Loads color version from TimelineItem named name Parameters: Name Type Description Default name str version name required type Literal ['local', 'remote'] whether to load a local or remote color version required Returns: Name Type Description bool bool True if successful, False otherwise","title":"load_color_version()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.rename_version","text":"Renames a color version named oldname to newname on this TimelineItem Parameters: Name Type Description Default oldname str current version name required newname str new version name required type Literal ['local', 'remote'] whether to rename a local or remote color version required Returns: Name Type Description bool bool True if successful, False otherwise","title":"rename_version()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.set_lut","text":"Sets lut located on lut_path at node_index Parameters: Name Type Description Default node_index int node index required lut_path str lut path required Returns: Name Type Description bool bool True if successful, False otherwise","title":"set_lut()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.set_cdl","text":"Sets CDL Parameters: Name Type Description Default cdl dict valid CDL dict required Example myclip . set_cdl ({ \"NodeIndex\" : \"1\" , \"Slope\" : \"0.5 0.4 0.2\" , \"Offset\" : \"0.4 0.3 0.2\" , \"Power\" : \"0.6 0.7 0.8\" , \"Saturation\" : \"0.65\" }) Returns: Name Type Description bool bool True if successful, False otherwise","title":"set_cdl()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.add_take","text":"Adds mediapool_item as a new take. Initializes a take selector for the timeline item if needed. By default, the full clip extents is added. startframe and endFrame are optional arguments used to specify the extents. Parameters: Name Type Description Default mediapool_item MediaPoolItem media pool item to add as take required startframe int start frame for new take. Defaults to 0. 0 endframe int end frame for new take. Defaults to 0. 0 Returns: Name Type Description bool bool description","title":"add_take()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.take_info","text":"Gets take info. If no takeindex provided, uses current selected take. Parameters: Name Type Description Default takeindex int take index to get info from. Defaults to current take. 0 Returns: Name Type Description dict Dict [ Any , Any ] description","title":"take_info()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.delete_take","text":"Deletes take index with index takeindex Parameters: Name Type Description Default takeindex int take index to be deleted required Returns: Name Type Description bool bool True if successful, False otherwise","title":"delete_take()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.finalize_take","text":"Finalizes take at takeindex . If no takeindex provided, finalizes current take. Parameters: Name Type Description Default takeindex int take index to be finalized. Defaults to current take. 0 Returns: Name Type Description bool bool description","title":"finalize_take()"},{"location":"timelineitem/#pydavinci.wrappers.timelineitem.TimelineItem.copy_grade_to","text":"Copies the current grade to all the items in timneline_items list Parameters: Name Type Description Default timeline_items list list with clips for the grade to be applied required Returns: Name Type Description bool bool True if successful, False otherwise","title":"copy_grade_to()"},{"location":"examples/premiereproxies/","text":"Premiere Proxies Just show me the code We all know about Premieres particular need for proxies. They have to be: Same aspect ratio as the original files Otherwise you end up with stretched proxies, and no one likes that. Same number of audio tracks as the original files This doesn't make sense, but that's how it is. Ideally same timecode Because otherwise you're going to have headaches. So you end up having to: Create proxies in Premiere and hope you have a nice 16x9 aspect ratio because that's what the default presets use. Realize you have media mixed between DCI 4k and UHD and now you gotta create an individual encoding preset Realize you have to create a Media Encoder encoding preset If you ever had to do that at 2am you know that it works so badly it's not even funny. You create the preset and it tries to copy the files, or it can't import the preset into Premiere, or a thousand other weird things. Then you decide to do just transcode everything in Davinci Resolve, which is probably what you should've done in the first place, but you still need to render everything in the same aspect ratio. Let's fix that and hopefully come home early The code Importing pydavinci Assuming we have pydavinci installed and have a Davinci project open, let's create a premiere_proxies.py file and import and define the objects we're going to use. premiere_proxies.py from pydavinci import davinci resolve = davinci . Resolve () project = resolve . project project_manager = resolve . project_manager media_pool = resolve . media_pool media_storage = resolve . media_storage Tip You can also programatically create a project. Check out Project Setting up a folder to import to Now let's create a folder on the media pool root folder, and set it as the current folder. ocf_folder = media_pool . add_subfolder ( 'OCF' , media_pool . root_folder ) media_pool . set_current_folder ( ocf_folder ) Info OCF means Original Camera Format Defining our function Let's define our function to generate the Premiere proxies: def generate_premiere_proxies ( input_dir , proxyfactor , output_dir ): Our function will take as parameters: input_dir : a path to a folder containing all our media output_dir : output directory for our proxies proxyfactor : by how much we will reduce the resolution for the proxies Info proxyfactor is the number to divide the original resolution to. Example: A proxyfactor of 1 on a 1920x1080 resolution will give you a 1920x1080 resolution proxy. A proxyfactor of 1.5 on a 1920x1080 resolution will give you a 1280x720 resolution proxy. A proxyfactor of 2 on a 1920x1080 resolution will give you a 960x540 resolution proxy Importing Media Now we can import the media in our project, and figure out what resolutions they are def generate_premiere_proxies ( input_dir , proxyfactor , output_dir ): media_pool . import_media ( input_dir ) clips_res = defaultdict ( list ) for media in ocf_folder . clips : clips_res [ media . properties [ 'Resolution' ]] . append ( media ) We first import our media using the media_pool.import_media() method, which imports all valid(as judged by Resolve) media files from input_dir into the media pool on our current folder. We then create a defaultdict that we will use to store all resolutions from the media. Then we loop for each MediaPoolItem in the ocf_folder.clips to grab each clip resolution, and store it in the clips_res dictionary which will end up looking like this: clips_res = { '1920x1080' : [ MediaPoolItem1 , MediaPoolItem2 ], '3840x2160' : [ MediaPoolItem3 , MediaPoolItem4 ], ... } Tip We're using a defaultdict to simplify our loop. If we used a regular dict, the first time we find a resolution we would have to first initiate it with a list value and then append to it. This way we don't need to check if we've seen this resolution before or not. Now while the Resolve API is very powerful, it still lacks a way for us to set the default behavior of exporting audio channels to Same as Source , which is what we need for Premiere.. So now let's head to Davinci and create and save a render preset with that option enabled. On the Audio tab, we make sure we're exporting audio and we select Same as source for the audio channels. This ensures that our proxy media can be linked without issue in Premiere. Save the preset as Proxies_Preset Now that we created our preset, let's make sure it's activated when we render the clips by using the project.set_preset() method. def generate_premiere_proxies ( input_dir , output_dir , proxyfactor ): ... project . set_preset ( \"Proxy_Preset\" ) We've imported and grabbed all clips resolutions, and now we can start our main loop. Creating render jobs First let's create an empty list which will contain our render jobs, then start our main loop and create a folder for each resolution we have and move the correct clips to that folder. def generate_premiere_proxies ( input_dir , output_dir , proxyfactor ): ... render_ids = [] for key in clips_res . keys (): res_x , res_y = key . split ( \"x\" ) # (1) res_folder = media_pool . add_subfolder ( key , ocf_folder ) clips = clips_res [ key ] # (2) media_pool . move_clips ( clips , res_folder ) When we grab resolutions from DaVinci, they come as a string, eg: \"1920x1080\" . We split the resolution to get the width and height We create a new variable containing the list of MediaPoolItem s for our current resolution in the loop. Make sure to click the buttons in the code above for more information Now we need to create a timeline containing all our MediaPoolItem s for the current resolution in the loop. We then activate that timeline and set the timeline resolution to be the same as the clip's resolutions, to avoid any letterboxing. def generate_premiere_proxies ( input_dir , output_dir , proxyfactor ): ... render_ids = [] for key in clips_res . keys (): ... media_pool . create_timeline_from_clips ( res_folder . name , # (1) res_folder . clips ) timeline = project . timeline timeline . set_setting ( \"useCustomSettings\" , \"1\" ) # (2) timeline . set_setting ( \"timelineResolutionWidth\" , res_x ) timeline . set_setting ( \"timelineResolutionHeight\" , res_y ) This is for the created timeline name. We're using the Folder name from before, which is set to be a string representing the resolution. This allows us to set custom resolutions and framerates for timelines more easily through the Python API, without having to mess with the Project Settings. For the next step, we need to set our render settings. Let's calculate our desired rendered resolution using our provided proxyfactor , set our render format/codec and output directory. def generate_premiere_proxies ( input_dir , output_dir , proxyfactor ): ... render_ids = [] for key in clips_res . keys (): ... project . set_render_format_and_codec ( \"mp4\" , \"H264\" ) render_settings = { # (1) \"FormatWidth\" : ( int ( res_x ) // proxyfactor ), # (2) \"FormatHeight\" : ( int ( res_y ) // proxyfactor ), \"TargetDir\" : output_dir , } project . set_render_settings ( render_settings ) The valid render settings that you can change are available at Project.set_render_settings() The \\\\ floor operator ensures we get an int back and not a float Warning If for any reason your render resolution ends up being an odd number, DaVinci will throw an error in the GUI and your script won't be able to continue. Now we're almost done! Just add the current timeline and render settings to the render queue, and append it to our render_ids list def generate_premiere_proxies ( input_dir , output_dir , proxyfactor ): ... render_ids = [] for key in clips_res . keys (): ... render_id = project . add_renderjob () render_ids . append ( render_id ) return render_ids Render time! Now we can get our job_ids and render them out!: job_ids = generate_premiere_proxies ( \"Path/To/Folder/With/Clips\" , \"Path/To/Output/Folder, proxyfactor = 2 , ) project . render ( job_ids ) Resolve will start rendering all our timelines with our clips, and in the end we'll have proxies ready to be edited by Premiere. Check out the full code here , with some extra functionality at the end which just prints out a nice message on render times left and total render time.","title":"Create Premiere Proxies"},{"location":"examples/premiereproxies/#premiere-proxies","text":"","title":"Premiere Proxies"},{"location":"examples/premiereproxies/#the-code","text":"","title":"The code"},{"location":"examples/premiereproxies/#importing-pydavinci","text":"Assuming we have pydavinci installed and have a Davinci project open, let's create a premiere_proxies.py file and import and define the objects we're going to use. premiere_proxies.py from pydavinci import davinci resolve = davinci . Resolve () project = resolve . project project_manager = resolve . project_manager media_pool = resolve . media_pool media_storage = resolve . media_storage Tip You can also programatically create a project. Check out Project","title":"Importing pydavinci"},{"location":"examples/premiereproxies/#setting-up-a-folder-to-import-to","text":"Now let's create a folder on the media pool root folder, and set it as the current folder. ocf_folder = media_pool . add_subfolder ( 'OCF' , media_pool . root_folder ) media_pool . set_current_folder ( ocf_folder ) Info OCF means Original Camera Format","title":"Setting up a folder to import to"},{"location":"examples/premiereproxies/#defining-our-function","text":"Let's define our function to generate the Premiere proxies: def generate_premiere_proxies ( input_dir , proxyfactor , output_dir ): Our function will take as parameters: input_dir : a path to a folder containing all our media output_dir : output directory for our proxies proxyfactor : by how much we will reduce the resolution for the proxies Info proxyfactor is the number to divide the original resolution to. Example: A proxyfactor of 1 on a 1920x1080 resolution will give you a 1920x1080 resolution proxy. A proxyfactor of 1.5 on a 1920x1080 resolution will give you a 1280x720 resolution proxy. A proxyfactor of 2 on a 1920x1080 resolution will give you a 960x540 resolution proxy","title":"Defining our function"},{"location":"examples/premiereproxies/#importing-media","text":"Now we can import the media in our project, and figure out what resolutions they are def generate_premiere_proxies ( input_dir , proxyfactor , output_dir ): media_pool . import_media ( input_dir ) clips_res = defaultdict ( list ) for media in ocf_folder . clips : clips_res [ media . properties [ 'Resolution' ]] . append ( media ) We first import our media using the media_pool.import_media() method, which imports all valid(as judged by Resolve) media files from input_dir into the media pool on our current folder. We then create a defaultdict that we will use to store all resolutions from the media. Then we loop for each MediaPoolItem in the ocf_folder.clips to grab each clip resolution, and store it in the clips_res dictionary which will end up looking like this: clips_res = { '1920x1080' : [ MediaPoolItem1 , MediaPoolItem2 ], '3840x2160' : [ MediaPoolItem3 , MediaPoolItem4 ], ... } Tip We're using a defaultdict to simplify our loop. If we used a regular dict, the first time we find a resolution we would have to first initiate it with a list value and then append to it. This way we don't need to check if we've seen this resolution before or not. Now while the Resolve API is very powerful, it still lacks a way for us to set the default behavior of exporting audio channels to Same as Source , which is what we need for Premiere.. So now let's head to Davinci and create and save a render preset with that option enabled. On the Audio tab, we make sure we're exporting audio and we select Same as source for the audio channels. This ensures that our proxy media can be linked without issue in Premiere. Save the preset as Proxies_Preset Now that we created our preset, let's make sure it's activated when we render the clips by using the project.set_preset() method. def generate_premiere_proxies ( input_dir , output_dir , proxyfactor ): ... project . set_preset ( \"Proxy_Preset\" ) We've imported and grabbed all clips resolutions, and now we can start our main loop.","title":"Importing Media"},{"location":"examples/premiereproxies/#creating-render-jobs","text":"First let's create an empty list which will contain our render jobs, then start our main loop and create a folder for each resolution we have and move the correct clips to that folder. def generate_premiere_proxies ( input_dir , output_dir , proxyfactor ): ... render_ids = [] for key in clips_res . keys (): res_x , res_y = key . split ( \"x\" ) # (1) res_folder = media_pool . add_subfolder ( key , ocf_folder ) clips = clips_res [ key ] # (2) media_pool . move_clips ( clips , res_folder ) When we grab resolutions from DaVinci, they come as a string, eg: \"1920x1080\" . We split the resolution to get the width and height We create a new variable containing the list of MediaPoolItem s for our current resolution in the loop. Make sure to click the buttons in the code above for more information Now we need to create a timeline containing all our MediaPoolItem s for the current resolution in the loop. We then activate that timeline and set the timeline resolution to be the same as the clip's resolutions, to avoid any letterboxing. def generate_premiere_proxies ( input_dir , output_dir , proxyfactor ): ... render_ids = [] for key in clips_res . keys (): ... media_pool . create_timeline_from_clips ( res_folder . name , # (1) res_folder . clips ) timeline = project . timeline timeline . set_setting ( \"useCustomSettings\" , \"1\" ) # (2) timeline . set_setting ( \"timelineResolutionWidth\" , res_x ) timeline . set_setting ( \"timelineResolutionHeight\" , res_y ) This is for the created timeline name. We're using the Folder name from before, which is set to be a string representing the resolution. This allows us to set custom resolutions and framerates for timelines more easily through the Python API, without having to mess with the Project Settings. For the next step, we need to set our render settings. Let's calculate our desired rendered resolution using our provided proxyfactor , set our render format/codec and output directory. def generate_premiere_proxies ( input_dir , output_dir , proxyfactor ): ... render_ids = [] for key in clips_res . keys (): ... project . set_render_format_and_codec ( \"mp4\" , \"H264\" ) render_settings = { # (1) \"FormatWidth\" : ( int ( res_x ) // proxyfactor ), # (2) \"FormatHeight\" : ( int ( res_y ) // proxyfactor ), \"TargetDir\" : output_dir , } project . set_render_settings ( render_settings ) The valid render settings that you can change are available at Project.set_render_settings() The \\\\ floor operator ensures we get an int back and not a float Warning If for any reason your render resolution ends up being an odd number, DaVinci will throw an error in the GUI and your script won't be able to continue. Now we're almost done! Just add the current timeline and render settings to the render queue, and append it to our render_ids list def generate_premiere_proxies ( input_dir , output_dir , proxyfactor ): ... render_ids = [] for key in clips_res . keys (): ... render_id = project . add_renderjob () render_ids . append ( render_id ) return render_ids","title":"Creating render jobs"},{"location":"examples/premiereproxies/#render-time","text":"Now we can get our job_ids and render them out!: job_ids = generate_premiere_proxies ( \"Path/To/Folder/With/Clips\" , \"Path/To/Output/Folder, proxyfactor = 2 , ) project . render ( job_ids ) Resolve will start rendering all our timelines with our clips, and in the end we'll have proxies ready to be edited by Premiere. Check out the full code here , with some extra functionality at the end which just prints out a nice message on render times left and total render time.","title":"Render time!"},{"location":"settings/","text":"Project vs. Timeline Settings By default, Project settings apply to all Timeline s in the project. To change that behavior, you need to use the method Timeline.custom_settings(True) . This will allow timeline settings to be independent from the project settings. You could then have a Project resolution of 1920x1080 for example and a Timeline resolution of 3840x2160 . Auto-completion and error catching for settings in the IDE Literals Whenever you see Literal on the type hints in the documentation, it means that the values listed need to be literally as shown. These literals were gathered by testing which settings are valid on the interface. Note Not all settings have been tested. For a fallback, you can still use the regular get_setting() and set_settings() methods on Project and Timeline","title":"Quickstart on settings"},{"location":"settings/#project-vs-timeline-settings","text":"By default, Project settings apply to all Timeline s in the project. To change that behavior, you need to use the method Timeline.custom_settings(True) . This will allow timeline settings to be independent from the project settings. You could then have a Project resolution of 1920x1080 for example and a Timeline resolution of 3840x2160 . Auto-completion and error catching for settings in the IDE","title":"Project vs. Timeline Settings"},{"location":"settings/#literals","text":"Whenever you see Literal on the type hints in the documentation, it means that the values listed need to be literally as shown. These literals were gathered by testing which settings are valid on the interface. Note Not all settings have been tested. For a fallback, you can still use the regular get_setting() and set_settings() methods on Project and Timeline","title":"Literals"},{"location":"settings/project/","text":"Base settings settings . graphics_white_level : int Valid numbers: 100 to 4000 settings . image_deinterlace_quality : Literal [ 'high' , 'normal' ] settings . image_enable_field_processing : bool settings . image_motion_estimation_mode : Literal [ 'enhancedBetter' , 'enhancedFaster' , 'standardFaster' , 'standardBetter' ] settings . image_motion_estimation_range : Literal [ 'small' , 'larger' , 'medium' ] settings . image_resize_mode : Literal [ 'smoother' , 'bicubic' , 'bilinear' , 'sharper' , 'box' , 'catrom' , 'cubic' , 'gaussian' , 'lanczos' , 'linear' , 'mitchell' , 'nearestNeighbor' , 'quadratic' , 'sinc' ] settings . image_resizing_gamma : str settings . image_retime_interpolation : Literal [ 'nearest' , 'frameBlend' , 'opticalFlow' ] settings . limit_subtitle_cpl : str settings . limit_subtitle_caption_duration_sec : int settings . super_scale_noise_reduction : Literal [ 'Low' , 'Medium' , 'High' ] settings . super_scale_sharpness : Literal [ 'Low' , 'Medium' , 'High' ] settings . timeline_frame_rate_mismatch_behavior : Literal [ 'fcp7' , 'fcpx' , 'none' , 'resolve' ] settings . timeline_input_res_mismatch_custom_preset : Optional [ str ] settings . timeline_input_res_mismatch_use_custom_preset : str settings . timeline_output_res_mismatch_custom_preset : Optional [ str ] settings . timeline_output_res_mismatch_use_custom_preset : bool settings . timeline_playback_frame_rate : str settings . timeline_save_thumbs_in_project : bool settings . timeline_working_luminance : int settings . timeline_working_luminance_mode : str settings . super_scale : Literal [ 'auto' , 'no_scaling' , '2x' , '3x' , '4x' ] settings . video_data_levels : Literal [ 'Video' , 'Full' ] settings . video_data_levels_retain_subblock_and_super_white_data : bool settings . monitor_bit_depth : int settings . monitor_format : str settings . monitor_matrix_override_for422_sdi : Literal [ 'Rec.2020' , 'Rec.709' , 'Rec.601' ] settings . monitor_sdi_configuration : Literal [ 'quad_link' , 'dual_link' , 'single_link' ] settings . monitor_scaling : Literal [ 'bilinear' , 'basic' , 'Bilinear' , 'Basic' ] settings . monitor_use444_sdi : bool settings . monitor_use_hdr_over_hdmi : bool settings . monitor_use_level_a : bool settings . monitor_use_matrix_override_for422_sdi : bool settings . monitor_use_stereo_sdi : bool Audio Settings settings . audio . capture_num_channels : int Valid numbers: 2 to 16 | multiple_of=2 settings . audio . output_has_timecode : bool settings . audio . playout_num_channels : int Valid numbers: 2 to 16 | multiple_of=2 settings . audio . limit_meter_align_level : int Valid numbers: -30 to 0 settings . audio . limit_meter_display_mode : Literal [ 'track_source' , 'post_fader' ] settings . audio . limit_meter_high_level : int Valid numbers: -30 to 0 settings . audio . limit_meter_lufs : str settings . audio . limit_meter_loudness_scale : Literal [ 'ebu_18_scale' , 'ebu_9_scale' ] settings . audio . limit_meter_low_level : int Valid numbers: -30 to 0 settings . color . aces_gamut_compress_type : Optional [ Literal [ 'ACES reference gamut compress' ]] settings . color . aces_idt : str settings . color . aces_node_lut_processing_space : Literal [ 'acesAp0Linear' , 'acesccAp1' ] settings . color . aces_odt : str settings . color . gallery_stills_location : Optional [ Union [ DirectoryPath , str ]] settings . color . gallery_stills_naming_custom_pattern : Optional [ str ] settings . color . gallery_stills_naming_enabled : bool settings . color . gallery_stills_naming_pattern : Literal [ 'clipName' , 'versionName' , 'sourceTimecode' , 'timelineTimecode' , 'timelineName' , 'displayLUTName' , 'customLabel' ] settings . color . gallery_stills_naming_with_still_number : Literal [ 'off' , 'suffix' , 'prefix' ] settings . color . keyframe_dynamics_end_profile : int Valid numbers: 0 to 11 settings . color . keyframe_dynamics_start_profile : int Valid numbers: 0 to 11 settings . color . color_luminance_mixer_default_zero : bool settings . color . color_science_mode : Literal [ 'davinciYRGB' , 'davinciYRGBColorManagedv2' , 'acescc' , 'acescct' ] settings . color . color_space_input : str settings . color . color_space_input_gamma : Optional [ str ] settings . color . color_space_output : str settings . color . color_space_output_gamma : Optional [ str ] settings . color . color_space_output_gamut_mapping : Optional [ str ] settings . color . color_space_output_gamut_saturation_knee : float settings . color . color_space_output_gamut_saturation_max : str settings . color . color_space_output_tone_luminance_max : int settings . color . color_space_output_tone_mapping : Optional [ str ] settings . color . color_space_timeline : str settings . color . color_space_timeline_gamma : Optional [ str ] settings . color . use_bgr_pixel_order_for_dpx : bool settings . color . use_contrast_s_curve : bool settings . color . use_legacy_log_grades : int Valid numbers: 1 to 2 settings . color . use_local_versions_as_default : bool settings . color . use_stereo_convergence_for_effects : bool settings . color . version1_name : Optional [ str ] settings . color . version2_name : Optional [ str ] settings . color . version3_name : Optional [ str ] settings . color . version4_name : Optional [ str ] settings . color . version5_name : Optional [ str ] settings . color . version6_name : Optional [ str ] settings . color . version7_name : Optional [ str ] settings . color . version8_name : Optional [ str ] settings . color . version9_name : Optional [ str ] settings . color . version10_name : Optional [ str ] settings . color . hdr10_plus_controls_on : bool settings . color . hdr_dolby_controls_on : bool settings . color . hdr_dolby_master_display : Optional [ str ] settings . color . hdr_dolby_version : Literal [ '4.0' , '2.9' ] settings . color . hdr_mastering_luminance_max : int Valid numbers: 100 to 10000 settings . color . hdr_mastering_on : bool settings . color . use_ca_transform : bool settings . color . use_color_space_aware_grading_tools : bool settings . color . use_inverse_drt : bool settings . color . output_drt : Optional [ str ] settings . color . output_drt_sat_rolloff_limit : int Valid numbers: 500 to 20000 settings . color . output_drt_sat_rolloff_start : int Valid numbers: 1 to 500 settings . color . rcm_preset_mode : Literal [ 'HDR Rec.2020 Intermediate' , 'SDR Rec.709' , 'Custom' ] settings . color . separate_color_space_and_gamma : bool settings . color . input_drt : Optional [ Literal [ 'None' , 'Simple' , 'Luminance Mapping' , 'DaVinci' , 'Saturation Preserving' ]] settings . color . input_drt_sat_rolloff_limit : int Valid numbers: 500 to 20000 settings . color . input_drt_sat_rolloff_start : int Valid numbers: 1 to 500 settings . color . auto_color_manage : bool settings . color . limit_broadcast_safe_levels : Literal [ '20_120' , '10_110' , '0_100' ] settings . color . limit_broadcast_safe : bool Performance Settings settings . perf . auto_render_cache_after_time : int Valid numbers: 1 to 30 settings . perf . auto_render_cache_composite : bool settings . perf . auto_render_cache_enable : bool settings . perf . auto_render_cache_fu_effect : bool settings . perf . auto_render_cache_transition : bool settings . perf . cache_clips_location : Optional [ Union [ Path , str ]] settings . perf . optimised_codec : Literal [ 'rgb' , 'dnxhd_444_12b' , 'dnxhd_hqx_12b' , 'dnxhd_hq' , 'dnxhd_sq' , 'dnxhd_lb' , 'CFHDb64a' , 'CFHDv210' , 'apch' ] settings . perf . optimised_media_on : bool settings . perf . optimized_resolution_ratio : Literal [ 'original' , 'half' , 'quarter' , 'one_eighth' , 'one_sixteenth' , 'auto' ] settings . perf . proxy_media_on : bool settings . perf . proxy_resolution_ratio : Literal [ 'original' , 'half' , 'quarter' ] settings . perf . render_cache_codec : Literal [ 'rgb' , 'dnxhd_444_12b' , 'dnxhd_hqx_12b' , 'dnxhd_hq' , 'dnxhd_sq' , 'dnxhd_lb' , 'CFHDb64a' , 'CFHDv210' , 'apch' ] settings . perf . render_cache_mode : Literal [ 'user' , 'smart' , 'none' ] Video Deck settings settings . deck . add32_pulldown : bool settings . deck . bit_depth : str settings . deck . format : str settings . deck . non_auto_edit_frames : bool settings . deck . output_sync_source : str settings . deck . preroll_sec : int Valid numbers: 2 to 8 settings . deck . sdi_configuration : str settings . deck . use444_sdi : bool settings . deck . use_auto_edit : bool settings . deck . use_stereo_sdi : bool Video Capture Settings settings . capture . codec : Optional [ Literal [ 'rgb' , 'dnxhd_720p145' , 'dnxhd_720p220' , 'dnxhd_720p220X' , 'dnxhd_1080i145' , 'dnxhd_1080i220' , 'dnxhd_1080i220X' , 'dnxhd_1080p36' , 'dnxhd_1080p145' , 'dnxhd_1080p220' , 'dnxhd_1080p220X' , 'dnxhd_1080p440X' , 'r210' , 'yuv' , 'v210 ' , 'apch' ]] settings . capture . format : Optional [ Literal [ 'mov' , 'dpx' ]] settings . capture . ingest_handles : int Valid numbers: 0 to 9999 settings . capture . location : Optional [ Union [ Path , str ]] settings . capture . mode : Literal [ 'video_only' , 'video_audio' ] Video Playout Settings settings . playout . audio_frames_offset : int Valid numbers: 0 to 99 settings . playout . batch_head_duration : int Valid numbers: 0 to 99 settings . playout . batch_tail_duration : int Valid numbers: 0 to 99 settings . playout . ltc_frames_offset : int Valid numbers: 0 to 20 settings . playout . mode : Literal [ 'video_only' , 'audio_only' , 'video_audio' ] settings . playout . show_ltc : bool settings . playout . show_source_timecode : bool Timeline Settings settings . timeline . drop_frame_timecode : bool settings . timeline . frame_rate : float settings . timeline . input_res_mismatch_behavior : Literal [ 'centerCrop' , 'scaleToCrop' , 'scaleToFit' , 'stretch' ] settings . timeline . interlace_processing : bool settings . timeline . output_pixel_aspect_ratio : Literal [ 'square' , 'cinemascope' ] settings . timeline . output_res_match_timeline_res : bool settings . timeline . output_res_mismatch_behavior : Literal [ 'centerCrop' , 'scaleToCrop' , 'scaleToFit' , 'stretch' ] settings . timeline . output_resolution_height : int settings . timeline . output_resolution_width : int settings . timeline . pixel_aspect_ratio : Literal [ 'square' , 'cinemascope' ] settings . timeline . resolution_height : int settings . timeline . resolution_width : int","title":"Project settings"},{"location":"settings/project/#base-settings","text":"","title":"Base settings"},{"location":"settings/project/#pydavinci.wrappers.settings.components.ProjectUniqueSettings.graphics_white_level","text":"","title":"graphics_white_level"},{"location":"settings/project/#pydavinci.wrappers.settings.components.ProjectUniqueSettings.image_deinterlace_quality","text":"","title":"image_deinterlace_quality"},{"location":"settings/project/#pydavinci.wrappers.settings.components.ProjectUniqueSettings.image_enable_field_processing","text":"","title":"image_enable_field_processing"},{"location":"settings/project/#pydavinci.wrappers.settings.components.ProjectUniqueSettings.image_motion_estimation_mode","text":"","title":"image_motion_estimation_mode"},{"location":"settings/project/#pydavinci.wrappers.settings.components.ProjectUniqueSettings.image_motion_estimation_range","text":"","title":"image_motion_estimation_range"},{"location":"settings/project/#pydavinci.wrappers.settings.components.ProjectUniqueSettings.image_resize_mode","text":"","title":"image_resize_mode"},{"location":"settings/project/#pydavinci.wrappers.settings.components.ProjectUniqueSettings.image_resizing_gamma","text":"","title":"image_resizing_gamma"},{"location":"settings/project/#pydavinci.wrappers.settings.components.ProjectUniqueSettings.image_retime_interpolation","text":"","title":"image_retime_interpolation"},{"location":"settings/project/#pydavinci.wrappers.settings.components.ProjectUniqueSettings.limit_subtitle_cpl","text":"","title":"limit_subtitle_cpl"},{"location":"settings/project/#pydavinci.wrappers.settings.components.ProjectUniqueSettings.limit_subtitle_caption_duration_sec","text":"","title":"limit_subtitle_caption_duration_sec"},{"location":"settings/project/#pydavinci.wrappers.settings.components.ProjectUniqueSettings.super_scale_noise_reduction","text":"","title":"super_scale_noise_reduction"},{"location":"settings/project/#pydavinci.wrappers.settings.components.ProjectUniqueSettings.super_scale_sharpness","text":"","title":"super_scale_sharpness"},{"location":"settings/project/#pydavinci.wrappers.settings.components.ProjectUniqueSettings.timeline_frame_rate_mismatch_behavior","text":"","title":"timeline_frame_rate_mismatch_behavior"},{"location":"settings/project/#pydavinci.wrappers.settings.components.ProjectUniqueSettings.timeline_input_res_mismatch_custom_preset","text":"","title":"timeline_input_res_mismatch_custom_preset"},{"location":"settings/project/#pydavinci.wrappers.settings.components.ProjectUniqueSettings.timeline_input_res_mismatch_use_custom_preset","text":"","title":"timeline_input_res_mismatch_use_custom_preset"},{"location":"settings/project/#pydavinci.wrappers.settings.components.ProjectUniqueSettings.timeline_output_res_mismatch_custom_preset","text":"","title":"timeline_output_res_mismatch_custom_preset"},{"location":"settings/project/#pydavinci.wrappers.settings.components.ProjectUniqueSettings.timeline_output_res_mismatch_use_custom_preset","text":"","title":"timeline_output_res_mismatch_use_custom_preset"},{"location":"settings/project/#pydavinci.wrappers.settings.components.ProjectUniqueSettings.timeline_playback_frame_rate","text":"","title":"timeline_playback_frame_rate"},{"location":"settings/project/#pydavinci.wrappers.settings.components.ProjectUniqueSettings.timeline_save_thumbs_in_project","text":"","title":"timeline_save_thumbs_in_project"},{"location":"settings/project/#pydavinci.wrappers.settings.components.ProjectUniqueSettings.timeline_working_luminance","text":"","title":"timeline_working_luminance"},{"location":"settings/project/#pydavinci.wrappers.settings.components.ProjectUniqueSettings.timeline_working_luminance_mode","text":"","title":"timeline_working_luminance_mode"},{"location":"settings/project/#pydavinci.wrappers.settings.components.CommonSettings.super_scale","text":"","title":"super_scale"},{"location":"settings/project/#pydavinci.wrappers.settings.components.CommonSettings.video_data_levels","text":"","title":"video_data_levels"},{"location":"settings/project/#pydavinci.wrappers.settings.components.CommonSettings.video_data_levels_retain_subblock_and_super_white_data","text":"","title":"video_data_levels_retain_subblock_and_super_white_data"},{"location":"settings/project/#pydavinci.wrappers.settings.components.CommonMonitor.monitor_bit_depth","text":"","title":"monitor_bit_depth"},{"location":"settings/project/#pydavinci.wrappers.settings.components.CommonMonitor.monitor_format","text":"","title":"monitor_format"},{"location":"settings/project/#pydavinci.wrappers.settings.components.CommonMonitor.monitor_matrix_override_for422_sdi","text":"","title":"monitor_matrix_override_for422_sdi"},{"location":"settings/project/#pydavinci.wrappers.settings.components.CommonMonitor.monitor_sdi_configuration","text":"","title":"monitor_sdi_configuration"},{"location":"settings/project/#pydavinci.wrappers.settings.components.CommonMonitor.monitor_scaling","text":"","title":"monitor_scaling"},{"location":"settings/project/#pydavinci.wrappers.settings.components.CommonMonitor.monitor_use444_sdi","text":"","title":"monitor_use444_sdi"},{"location":"settings/project/#pydavinci.wrappers.settings.components.CommonMonitor.monitor_use_hdr_over_hdmi","text":"","title":"monitor_use_hdr_over_hdmi"},{"location":"settings/project/#pydavinci.wrappers.settings.components.CommonMonitor.monitor_use_level_a","text":"","title":"monitor_use_level_a"},{"location":"settings/project/#pydavinci.wrappers.settings.components.CommonMonitor.monitor_use_matrix_override_for422_sdi","text":"","title":"monitor_use_matrix_override_for422_sdi"},{"location":"settings/project/#pydavinci.wrappers.settings.components.CommonMonitor.monitor_use_stereo_sdi","text":"","title":"monitor_use_stereo_sdi"},{"location":"settings/project/#audio-settings","text":"","title":"Audio Settings"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Audio.capture_num_channels","text":"","title":"capture_num_channels"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Audio.output_has_timecode","text":"","title":"output_has_timecode"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Audio.playout_num_channels","text":"","title":"playout_num_channels"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Audio.limit_meter_align_level","text":"","title":"limit_meter_align_level"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Audio.limit_meter_display_mode","text":"","title":"limit_meter_display_mode"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Audio.limit_meter_high_level","text":"","title":"limit_meter_high_level"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Audio.limit_meter_lufs","text":"","title":"limit_meter_lufs"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Audio.limit_meter_loudness_scale","text":"","title":"limit_meter_loudness_scale"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Audio.limit_meter_low_level","text":"","title":"limit_meter_low_level"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.aces_gamut_compress_type","text":"","title":"aces_gamut_compress_type"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.aces_idt","text":"","title":"aces_idt"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.aces_node_lut_processing_space","text":"","title":"aces_node_lut_processing_space"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.aces_odt","text":"","title":"aces_odt"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.gallery_stills_location","text":"","title":"gallery_stills_location"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.gallery_stills_naming_custom_pattern","text":"","title":"gallery_stills_naming_custom_pattern"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.gallery_stills_naming_enabled","text":"","title":"gallery_stills_naming_enabled"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.gallery_stills_naming_pattern","text":"","title":"gallery_stills_naming_pattern"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.gallery_stills_naming_with_still_number","text":"","title":"gallery_stills_naming_with_still_number"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.keyframe_dynamics_end_profile","text":"","title":"keyframe_dynamics_end_profile"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.keyframe_dynamics_start_profile","text":"","title":"keyframe_dynamics_start_profile"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.color_luminance_mixer_default_zero","text":"","title":"color_luminance_mixer_default_zero"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.color_science_mode","text":"","title":"color_science_mode"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.color_space_input","text":"","title":"color_space_input"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.color_space_input_gamma","text":"","title":"color_space_input_gamma"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.color_space_output","text":"","title":"color_space_output"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.color_space_output_gamma","text":"","title":"color_space_output_gamma"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.color_space_output_gamut_mapping","text":"","title":"color_space_output_gamut_mapping"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.color_space_output_gamut_saturation_knee","text":"","title":"color_space_output_gamut_saturation_knee"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.color_space_output_gamut_saturation_max","text":"","title":"color_space_output_gamut_saturation_max"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.color_space_output_tone_luminance_max","text":"","title":"color_space_output_tone_luminance_max"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.color_space_output_tone_mapping","text":"","title":"color_space_output_tone_mapping"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.color_space_timeline","text":"","title":"color_space_timeline"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.color_space_timeline_gamma","text":"","title":"color_space_timeline_gamma"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.use_bgr_pixel_order_for_dpx","text":"","title":"use_bgr_pixel_order_for_dpx"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.use_contrast_s_curve","text":"","title":"use_contrast_s_curve"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.use_legacy_log_grades","text":"","title":"use_legacy_log_grades"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.use_local_versions_as_default","text":"","title":"use_local_versions_as_default"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.use_stereo_convergence_for_effects","text":"","title":"use_stereo_convergence_for_effects"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.version1_name","text":"","title":"version1_name"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.version2_name","text":"","title":"version2_name"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.version3_name","text":"","title":"version3_name"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.version4_name","text":"","title":"version4_name"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.version5_name","text":"","title":"version5_name"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.version6_name","text":"","title":"version6_name"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.version7_name","text":"","title":"version7_name"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.version8_name","text":"","title":"version8_name"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.version9_name","text":"","title":"version9_name"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.version10_name","text":"","title":"version10_name"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.hdr10_plus_controls_on","text":"","title":"hdr10_plus_controls_on"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.hdr_dolby_controls_on","text":"","title":"hdr_dolby_controls_on"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.hdr_dolby_master_display","text":"","title":"hdr_dolby_master_display"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.hdr_dolby_version","text":"","title":"hdr_dolby_version"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.hdr_mastering_luminance_max","text":"","title":"hdr_mastering_luminance_max"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.hdr_mastering_on","text":"","title":"hdr_mastering_on"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.use_ca_transform","text":"","title":"use_ca_transform"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.use_color_space_aware_grading_tools","text":"","title":"use_color_space_aware_grading_tools"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.use_inverse_drt","text":"","title":"use_inverse_drt"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.output_drt","text":"","title":"output_drt"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.output_drt_sat_rolloff_limit","text":"","title":"output_drt_sat_rolloff_limit"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.output_drt_sat_rolloff_start","text":"","title":"output_drt_sat_rolloff_start"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.rcm_preset_mode","text":"","title":"rcm_preset_mode"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.separate_color_space_and_gamma","text":"","title":"separate_color_space_and_gamma"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.input_drt","text":"","title":"input_drt"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.input_drt_sat_rolloff_limit","text":"","title":"input_drt_sat_rolloff_limit"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.input_drt_sat_rolloff_start","text":"","title":"input_drt_sat_rolloff_start"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.auto_color_manage","text":"","title":"auto_color_manage"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.limit_broadcast_safe_levels","text":"","title":"limit_broadcast_safe_levels"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Color.limit_broadcast_safe","text":"","title":"limit_broadcast_safe"},{"location":"settings/project/#performance-settings","text":"","title":"Performance Settings"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Perf.auto_render_cache_after_time","text":"","title":"auto_render_cache_after_time"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Perf.auto_render_cache_composite","text":"","title":"auto_render_cache_composite"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Perf.auto_render_cache_enable","text":"","title":"auto_render_cache_enable"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Perf.auto_render_cache_fu_effect","text":"","title":"auto_render_cache_fu_effect"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Perf.auto_render_cache_transition","text":"","title":"auto_render_cache_transition"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Perf.cache_clips_location","text":"","title":"cache_clips_location"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Perf.optimised_codec","text":"","title":"optimised_codec"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Perf.optimised_media_on","text":"","title":"optimised_media_on"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Perf.optimized_resolution_ratio","text":"","title":"optimized_resolution_ratio"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Perf.proxy_media_on","text":"","title":"proxy_media_on"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Perf.proxy_resolution_ratio","text":"","title":"proxy_resolution_ratio"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Perf.render_cache_codec","text":"","title":"render_cache_codec"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Perf.render_cache_mode","text":"","title":"render_cache_mode"},{"location":"settings/project/#video-deck-settings","text":"","title":"Video Deck settings"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Deck.add32_pulldown","text":"","title":"add32_pulldown"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Deck.bit_depth","text":"","title":"bit_depth"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Deck.format","text":"","title":"format"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Deck.non_auto_edit_frames","text":"","title":"non_auto_edit_frames"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Deck.output_sync_source","text":"","title":"output_sync_source"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Deck.preroll_sec","text":"","title":"preroll_sec"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Deck.sdi_configuration","text":"","title":"sdi_configuration"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Deck.use444_sdi","text":"","title":"use444_sdi"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Deck.use_auto_edit","text":"","title":"use_auto_edit"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Deck.use_stereo_sdi","text":"","title":"use_stereo_sdi"},{"location":"settings/project/#video-capture-settings","text":"","title":"Video Capture Settings"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Capture.codec","text":"","title":"codec"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Capture.format","text":"","title":"format"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Capture.ingest_handles","text":"","title":"ingest_handles"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Capture.location","text":"","title":"location"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Capture.mode","text":"","title":"mode"},{"location":"settings/project/#video-playout-settings","text":"","title":"Video Playout Settings"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Playout.audio_frames_offset","text":"","title":"audio_frames_offset"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Playout.batch_head_duration","text":"","title":"batch_head_duration"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Playout.batch_tail_duration","text":"","title":"batch_tail_duration"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Playout.ltc_frames_offset","text":"","title":"ltc_frames_offset"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Playout.mode","text":"","title":"mode"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Playout.show_ltc","text":"","title":"show_ltc"},{"location":"settings/project/#pydavinci.wrappers.settings.components.Playout.show_source_timecode","text":"","title":"show_source_timecode"},{"location":"settings/project/#timeline-settings","text":"","title":"Timeline Settings"},{"location":"settings/project/#pydavinci.wrappers.settings.components.TimelineMeta.drop_frame_timecode","text":"","title":"drop_frame_timecode"},{"location":"settings/project/#pydavinci.wrappers.settings.components.TimelineMeta.frame_rate","text":"","title":"frame_rate"},{"location":"settings/project/#pydavinci.wrappers.settings.components.TimelineMeta.input_res_mismatch_behavior","text":"","title":"input_res_mismatch_behavior"},{"location":"settings/project/#pydavinci.wrappers.settings.components.TimelineMeta.interlace_processing","text":"","title":"interlace_processing"},{"location":"settings/project/#pydavinci.wrappers.settings.components.TimelineMeta.output_pixel_aspect_ratio","text":"","title":"output_pixel_aspect_ratio"},{"location":"settings/project/#pydavinci.wrappers.settings.components.TimelineMeta.output_res_match_timeline_res","text":"","title":"output_res_match_timeline_res"},{"location":"settings/project/#pydavinci.wrappers.settings.components.TimelineMeta.output_res_mismatch_behavior","text":"","title":"output_res_mismatch_behavior"},{"location":"settings/project/#pydavinci.wrappers.settings.components.TimelineMeta.output_resolution_height","text":"","title":"output_resolution_height"},{"location":"settings/project/#pydavinci.wrappers.settings.components.TimelineMeta.output_resolution_width","text":"","title":"output_resolution_width"},{"location":"settings/project/#pydavinci.wrappers.settings.components.TimelineMeta.pixel_aspect_ratio","text":"","title":"pixel_aspect_ratio"},{"location":"settings/project/#pydavinci.wrappers.settings.components.TimelineMeta.resolution_height","text":"","title":"resolution_height"},{"location":"settings/project/#pydavinci.wrappers.settings.components.TimelineMeta.resolution_width","text":"","title":"resolution_width"},{"location":"settings/timeline/","text":"settings . use_custom_settings : bool settings . drop_frame_timecode : bool settings . frame_rate : float settings . input_res_mismatch_behavior : Literal [ 'centerCrop' , 'scaleToCrop' , 'scaleToFit' , 'stretch' ] settings . interlace_processing : bool settings . output_pixel_aspect_ratio : Literal [ 'square' , 'cinemascope' ] settings . output_res_match_timeline_res : bool settings . output_res_mismatch_behavior : Literal [ 'centerCrop' , 'scaleToCrop' , 'scaleToFit' , 'stretch' ] settings . output_resolution_height : int settings . output_resolution_width : int settings . pixel_aspect_ratio : Literal [ 'square' , 'cinemascope' ] settings . resolution_height : int settings . resolution_width : int settings . monitor_bit_depth : int settings . monitor_format : str settings . monitor_matrix_override_for422_sdi : Literal [ 'Rec.2020' , 'Rec.709' , 'Rec.601' ] settings . monitor_sdi_configuration : Literal [ 'quad_link' , 'dual_link' , 'single_link' ] settings . monitor_scaling : Literal [ 'bilinear' , 'basic' , 'Bilinear' , 'Basic' ] settings . monitor_use444_sdi : bool settings . monitor_use_hdr_over_hdmi : bool settings . monitor_use_level_a : bool settings . monitor_use_matrix_override_for422_sdi : bool settings . monitor_use_stereo_sdi : bool","title":"Timeline settings"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.TimelineUniqueSettings.use_custom_settings","text":"","title":"use_custom_settings"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.TimelineMeta.drop_frame_timecode","text":"","title":"drop_frame_timecode"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.TimelineMeta.frame_rate","text":"","title":"frame_rate"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.TimelineMeta.input_res_mismatch_behavior","text":"","title":"input_res_mismatch_behavior"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.TimelineMeta.interlace_processing","text":"","title":"interlace_processing"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.TimelineMeta.output_pixel_aspect_ratio","text":"","title":"output_pixel_aspect_ratio"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.TimelineMeta.output_res_match_timeline_res","text":"","title":"output_res_match_timeline_res"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.TimelineMeta.output_res_mismatch_behavior","text":"","title":"output_res_mismatch_behavior"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.TimelineMeta.output_resolution_height","text":"","title":"output_resolution_height"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.TimelineMeta.output_resolution_width","text":"","title":"output_resolution_width"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.TimelineMeta.pixel_aspect_ratio","text":"","title":"pixel_aspect_ratio"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.TimelineMeta.resolution_height","text":"","title":"resolution_height"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.TimelineMeta.resolution_width","text":"","title":"resolution_width"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.CommonMonitor.monitor_bit_depth","text":"","title":"monitor_bit_depth"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.CommonMonitor.monitor_format","text":"","title":"monitor_format"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.CommonMonitor.monitor_matrix_override_for422_sdi","text":"","title":"monitor_matrix_override_for422_sdi"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.CommonMonitor.monitor_sdi_configuration","text":"","title":"monitor_sdi_configuration"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.CommonMonitor.monitor_scaling","text":"","title":"monitor_scaling"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.CommonMonitor.monitor_use444_sdi","text":"","title":"monitor_use444_sdi"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.CommonMonitor.monitor_use_hdr_over_hdmi","text":"","title":"monitor_use_hdr_over_hdmi"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.CommonMonitor.monitor_use_level_a","text":"","title":"monitor_use_level_a"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.CommonMonitor.monitor_use_matrix_override_for422_sdi","text":"","title":"monitor_use_matrix_override_for422_sdi"},{"location":"settings/timeline/#pydavinci.wrappers.settings.components.CommonMonitor.monitor_use_stereo_sdi","text":"","title":"monitor_use_stereo_sdi"}]}